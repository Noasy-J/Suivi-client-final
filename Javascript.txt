/************
  CONSTANTES
*************/



const SHEET_TEMPLATE_HEADER = 'Template En-Tête';
const SHEET_TEMPLATE_CLIENT = 'Template Ajout Client';
const SHEET_CLIENTS         = 'Client Régulier';
const SHEET_PONCTUEL        = 'Client Ponctuel';

const NB_ROWS_BLOCK = 2;            // blocs = 2 lignes (r1 infos haut / r2 infos bas)
const NB_COLS_BLOCK = 54;           // colonnes A..BB
const HEADER_RANGE  = 'A1:BB2';     // en-têtes (2 lignes)
const CLIENT_RANGE  = 'A1:BB2';     // gabarit d'un bloc client (2 lignes)

const COL_NOM     = 1; // A, ligne 1
const COL_CONTRAT = 2; // B, ligne 1
const COL_PRENOM  = 1; // A, ligne 2
const COL_TEL     = 2; // B, ligne 2


// Couleurs (semaine en cours)
const HIGHLIGHT_BORDER_COLOR = '#46828F';
const HIGHLIGHT_BORDER_STYLE = SpreadsheetApp.BorderStyle.DOUBLE;
const HIGHLIGHT_HEADER_BG    = '#46828F';
const HIGHLIGHT_HEADER_TEXT  = '#FFFFFF';
const HIGHLIGHT_COLUMN_BG    = '#CCF5FF';

// Alternance (fonds des blocs)
const ALT_COLOR_GREY  = '#f0f0f0';
const ALT_COLOR_LIGHT = '#ffffff';

// Prévisions (fonds)
const FORECAST_BG_OK     = '#FFE8C6'; // dans le délai (orange clair)
const FORECAST_BG        = '#FF5A5A'; // retard 1 semaine (rouge)
const FORECAST_BG_URGENT = '#990000'; // retard ≥ 2 semaines (rouge très foncé)
const FORECAST_BG_NEW    = '#9CCAFF'; // ➕ nouveau client (aucune intervention passée) — BLEU

// Propriétés (clé/val docs)
const PROP_WEEK_BORDER_COLS_PREFIX = 'WEEK_BORDER_COLS_';
const PROP_FORECAST_ENABLED        = 'FORECAST_ENABLED';      // '1' ou '0'
const PROP_FORECAST_PACKS_PREFIX   = 'FORECAST_PACKS_';       // par sheetId
const PROP_WEEK_LAST_ROWS_PREFIX = 'WEEK_LAST_ROWS_';

// Alias lisibles (pas d’impact fonctionnel)
const FIRST_DATA_ROW = 3;        // lignes 1..2 = en-têtes ; données à partir de 3
const FIRST_DATA_COL = 3;        // colonnes A..B = infos ; données calendaires dès C
const HEADER_ROWS    = 2;        // 2 lignes d’en-têtes
const TZ             = Session.getScriptTimeZone(); // évite les appels répétés

// --- CONSTS PRATIQUES ---
const CLIENT_SHEETS = [SHEET_CLIENTS, SHEET_PONCTUEL];
const LISTING_SHEET_NAME = 'Listing Prévisions 📞';

// Décalage de défilement (positif = voir un peu à droite de la semaine)
const SHIFT_RIGHT = 7; // remplace l'idée d'un nombre négatif

// Propriété: compter "Planifié 📆" comme une intervention effectuée ? '1' ou '0'
const PROP_FORECAST_PLANIF_IS_DONE = 'FORECAST_PLANIF_IS_DONE';




// Mois FR (accents)
const __MOIS_LONG__  = ['Janvier','Février','Mars','Avril','Mai','Juin','Juillet','Août','Septembre','Octobre','Novembre','Décembre'];
const __MOIS_COURT__ = ['Janv.','Févr.','Mars','Avr.','Mai','Juin','Juil.','Août','Sept.','Oct.','Nov.','Déc.'];

function moisLong_(idx0to11){ return __MOIS_LONG__[idx0to11] || String(idx0to11+1); }
function moisCourt_(idx0to11){ return __MOIS_COURT__[idx0to11] || String(idx0to11+1); }

function fmtJourMoisLong_(d) {
  if (!(d && Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.getTime()))) return '—';
  return d.getDate() + ' ' + moisLong_(d.getMonth());
}
function fmtJourMoisCourt_(d) {
  if (!(d && Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.getTime()))) return '';
  return d.getDate() + ' ' + moisCourt_(d.getMonth());
}


const __PLAGES_CACHE = new Map();


/************
  Batch de surbrillance (déféré)
*************/

let __HL_DEFER = false;
let __HL_BUCKET = null;
function beginHighlightBatch_() { __HL_DEFER = true; __HL_BUCKET = new Set(); }


function resurlignerApresMaj_(sheet) {
  if (__HL_DEFER) { if (sheet) __HL_BUCKET.add(sheet); return; }
  if (!sheet) return;
  try {
    // 🔧 Forcer un repeint complet : on invalide la mémo-cache (colonnes/hauteur)
    try {
      const props = PropertiesService.getDocumentProperties();
      const sid = sheet.getSheetId();
      props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX + sid);
      props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + '_' + sid);
    } catch (_) {}

    SpreadsheetApp.flush();

    // (ré)applique la semaine en cours (remet aussi l’alternance gris/blanc)
    mettreEnValeurColonneJourSurFeuille_(sheet, todayMidnight_());

    // Puis seulement ensuite, les prévisions + masquages si actifs
    if (isForecastEnabled_()) {
      clearPrevisionsSurFeuille_(sheet);
      appliquerPrevisionsSurFeuille_(sheet);
      try { appliquerMasquageS1SurFeuIle_(sheet); } catch(_){}
    }
    SpreadsheetApp.flush();
  } catch (e) { Logger.log(e); }
}


function tryGetUi_() {
  try { return SpreadsheetApp.getUi(); } catch (_) { return null; }
}


function safeAlert_(msg) {
  const ui = tryGetUi_();
  if (ui) ui.alert(String(msg));
}


function safeClearValidations_(rangeOrRangeList) {
  try {
    if (rangeOrRangeList.clearDataValidations) {
      rangeOrRangeList.clearDataValidations();
    } else if (rangeOrRangeList.setDataValidation) {
      rangeOrRangeList.setDataValidation(null);
    }
  } catch (_) {
    try {
      const ranges = rangeOrRangeList.getRanges ? rangeOrRangeList.getRanges() : [];
      ranges.forEach(r => r.setDataValidation && r.setDataValidation(null));
    } catch (__) {}
  }
}

function safeSetNumberFormat_(range, format) {
  try {
    if (format && typeof format === 'string') {
      range.setNumberFormat(format);
    } else {
      range.setNumberFormat('@'); // défaut: Texte
    }
  } catch (_) {
    // Ne bloque pas si Apps Script refuse
  }
}






function endHighlightBatch_() {
  try {
    if (!__HL_BUCKET || __HL_BUCKET.size === 0) return;
    SpreadsheetApp.flush();
    const today = todayMidnight_();

    __HL_BUCKET.forEach(sh => {
      try {
        // 🔧 Forcer un repeint complet sur chaque feuille du lot
        try {
          const props = PropertiesService.getDocumentProperties();
          const sid = sh.getSheetId();
          props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX + sid);
          props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + '_' + sid);
        } catch (_) {}

        mettreEnValeurColonneJourSurFeuille_(sh, today);

        if (isForecastEnabled_()) {
          clearPrevisionsSurFeuille_(sh);
          appliquerPrevisionsSurFeuille_(sh);
          try { appliquerMasquageS1SurFeuIle_(sheet); } catch(_){}
        }
      } catch (e) { Logger.log(e); }
    });

    SpreadsheetApp.flush();
  } finally {
    __HL_DEFER = false;
    __HL_BUCKET = null;
  }
}





/************
  MENU + TRIGGERS
*************/

/** Ouvre le menu personnalisé, (ré)applique surbrillance et focus.
 * @param {GoogleAppsScript.Events.SheetsOnOpen} e
 */

/** Ouvre le menu personnalisé et (ré)applique la surbrillance au refresh (F5). */
function onOpen(e) {
  try {
    e = e || {};

    // UI sûre
    var ui = null;
    try { ui = SpreadsheetApp.getUi(); } catch (_){}
    if (!ui && typeof tryGetUi_ === 'function') { try { ui = tryGetUi_(); } catch (_){ } }

    if (ui) {
      // 1) Gestion client 🏢
      ui.createMenu('Gestion client 🏢')
        .addItem('Ajouter un client ➕', 'ajouterClientDialog')
        .addItem('Modifier un client 🔄', 'modifierClientDialog')
        .addItem('Supprimer un client ❌', 'supprimerClientDialog')
        .addToUi();

      // 2) Prévisions 🔮 (— plus de sous-menu Masquages —)
      ui.createMenu('Prévisions 🔮')
        .addItem('Activer les prévisions ✅', 'activerPrevisionsMenu_')
        .addItem('Désactiver les prévisions ❌​', 'desactiverPrevisionsMenu_')
        .addItem('Listing téléphonique (priorisé) 📞', 'ouvrirListingPrevisionsDialog')
        .addSeparator()
        .addItem('Masquer un client 🕶️', 'masquerClientDialog')

        .addToUi();

      // 3) Cloture 🧾
      ui.createMenu('Cloture 🧾')
        .addItem('Synthèse transports (mensuelle) 🚛', 'ouvrirSyntheseTransportsDialog')
        .addToUi();

      // 4) Paramètre ⚙️
      ui.createMenu('Paramètre ⚙️')
        .addItem('Normaliser tous les téléphones 📱', 'normaliserTelephonesToutesFeuilles')
        .addSeparator()
        .addItem('Resynchroniser les templates 🎨', 'resynchroniserTemplatesMenu')
        .addItem('Reposer validations "Statut" ✅', 'resynchroniserValidationsStatutDepuisTemplate')
        .addItem('Recalculer validations (dates) ✅', 'recalculerValidationsDepuisMenu')
        .addItem('Réparer tout (surbrillance, prévisions, MFC)', 'reparerTout_')
        .addSeparator()
        .addSubMenu(
          ui.createMenu('Automatisation ⚙️')
            .addItem('Activer actions à l’ouverture', 'setupTriggers_')
            .addItem('Désactiver actions à l’ouverture', 'disableOpenTrigger_')
            .addSeparator()
            .addItem('Activer rafraîchissement quotidien (6h)', 'setupTriggersDaily_')
            .addItem('Désactiver rafraîchissement quotidien', 'disableDailyTrigger_')
            .addSeparator()
            .addItem('Rafraîchir maintenant', 'refreshNowMenu_')
        )
        .addToUi();
    }

    // 1) (optionnel) désactivation silencieuse à l’ouverture si elle existe déjà
    try { if (typeof desactiverPrevisionsSilencieuxAuDemarrage_ === 'function') desactiverPrevisionsSilencieuxAuDemarrage_(); } catch (_){}

    // 2) Forcer la re-détection / re-peinture de la surbrillance semaine en cours à chaque ouverture/refresh (F5)
    try {
      const ss    = SpreadsheetApp.getActiveSpreadsheet();
      const props = PropertiesService.getDocumentProperties();
      [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
        const sh = ss.getSheetByName(name); if (!sh) return;
        const sid = sh.getSheetId();
        props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + sid);
        props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX   + sid);
      });
      if (typeof surlignerSemaineEnCoursToutesFeuilles_ === 'function') {
        surlignerSemaineEnCoursToutesFeuilles_();
      }
    } catch (_){}

    // 3) Centrer la vue sur la semaine en surbrillance (si dispo)
    try { if (typeof focusHighlightedWeekAtOpen_ === 'function') focusHighlightedWeekAtOpen_(); } catch (_){}

  } catch (err) {
    var msg = (err && err.message) ? err.message : String(err);
    Logger.log('onOpen error: ' + msg);
    try { SpreadsheetApp.getActive().toast('onOpen error: ' + msg, 'Script', 5); } catch (_){}
  }
}







function setupTriggers_() {
  removeTriggersByHandler_('onOpenInstallable_');
   ScriptApp.newTrigger('onOpenInstallable_')
    .forSpreadsheet(SpreadsheetApp.getActiveSpreadsheet())
    .onOpen()
    .create();
  SpreadsheetApp.getActiveSpreadsheet().toast('Actions à l’ouverture activées ✅');
}


function disableOpenTrigger_() {
  const removed = removeTriggersByHandler_('onOpenInstallable_');
  SpreadsheetApp.getActiveSpreadsheet().toast(removed ? 'Actions à l’ouverture désactivées ✅' : 'Aucun déclencheur à supprimer.');
}

// Variante installable : même comportement si tu actives "Automatisation ▸ Activer actions à l’ouverture".
function onOpenInstallable_(e) {
  try {
    e = e || {};

    // (option actuel du projet) Désactivation silencieuse des prévisions au démarrage
    try { if (typeof desactiverPrevisionsSilencieuxAuDemarrage_ === 'function') desactiverPrevisionsSilencieuxAuDemarrage_(); } catch (_){}

    // ➕ NOUVEAU : forcer un repeint réel au déclencheur installable aussi
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const props = PropertiesService.getDocumentProperties();
      [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(function(name) {
        const sh = ss.getSheetByName(name);
        if (!sh) return;
        const sid = sh.getSheetId();
        props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + sid);
        props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX  + sid);
      });
      if (typeof surlignerSemaineEnCoursToutesFeuilles_ === 'function') {
        surlignerSemaineEnCoursToutesFeuilles_();
      }
    } catch (_) {}

    // Gèle les volets + focus semaine (inchangé)
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      if (ss && typeof ensureFrozenPanes_ === 'function') {
        [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(function(nom) {
          try { ensureFrozenPanes_(ss.getSheetByName(nom)); } catch (_){}
        });
      }
    } catch (_){}
    try { if (typeof focusHighlightedWeekAtOpen_ === 'function') focusHighlightedWeekAtOpen_(); } catch (_){}

  } catch (err) {
    const msg = logError_('onOpenInstallable_', err);
    toastSafe_('onOpenInstallable_ error: ' + msg, 'Script', 5);
  }
}



function setupTriggersDaily_() {
  const ssId = SpreadsheetApp.getActive().getId();
  // Supprime l'ancien s’il existe
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'refreshWeekHighlightDaily_') ScriptApp.deleteTrigger(t);
  });
  // Recrée une fois
  ScriptApp.newTrigger('refreshWeekHighlightDaily_').timeBased().atHour(6).everyDays(1).create();
}

function disableDailyTrigger_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'refreshWeekHighlightDaily_') ScriptApp.deleteTrigger(t);
  });
}

function refreshWeekHighlightDaily_() {
  try { surlignerSemaineEnCoursToutesFeuilles_(); } catch (err) { Logger.log(err); }
}


function refreshNowMenu_() {
  try {
    surlignerSemaineEnCoursToutesFeuilles_();
    focusHighlightedWeekAtOpen_();
    SpreadsheetApp.getActiveSpreadsheet().toast('Surbrillance mise à jour ✅', 'Gestion client', 3);
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast('Erreur pendant la mise à jour ❌', 'Gestion client', 5);
  }
}


function removeTriggersByHandler_(handlerName) {
  const triggers = ScriptApp.getProjectTriggers().filter(t => t.getHandlerFunction() === handlerName);
  triggers.forEach(t => ScriptApp.deleteTrigger(t));
  return triggers.length > 0;
}

/************
  SYNTHÈSE – valeurs par défaut (Paramètres) + ouverture modale
*************/

function getSyntheseDefaults_() {
  const tz = Session.getScriptTimeZone();
  const now = new Date();
  const moisNow = parseInt(Utilities.formatDate(now, tz, 'M'), 10); // 1..12
  let annee = getAnneeDeReference_();

  let mois = moisNow;
  try {
    const sh = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Paramètres');
    if (sh) {
      const m = Number(sh.getRange('B2').getValue());
      if (m >= 1 && m <= 12) mois = m;
    }
  } catch (_) {}

  return { annee, mois };
}
function ouvrirSyntheseTransportsDialog() {
  const t = HtmlService.createTemplateFromFile('syntheseTransports');
  t.defaults = getSyntheseDefaults_();               // ⇐ injecte {annee, mois}
  const html = t.evaluate().setWidth(820).setHeight(720);
  SpreadsheetApp.getUi().showModalDialog(html, 'Synthèse – Transports mensuels 🚛');
}


/************
  Utils – lecture / parsing
*************/


function extractTransportCount_(txt) {
  if (!txt) return 0;
  const s = String(txt).trim();

  // reconnaître "1/2" (avec espaces) ou le symbole "½", avec/sans "Transport(s)" et l'emoji 🚛
  if (/^\s*(?:1\s*\/\s*2|½)\s*Transport(?:s)?(?:\s*🚛)?\s*$/i.test(s)) {
    return 0.5;
  }

  // 1..5 Transport(s) 🚛
  const m = s.match(/^\s*([1-5])\s*Transport(?:s)?(?:\s*🚛)?\s*$/i);
  return m ? parseInt(m[1], 10) : 0;
}


function toDateOrNull_(v) {
  if (!v) return null;
  if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v.getTime())) return v;
  const s = String(v).trim();
  const m = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
  if (!m) return null;
  const d = parseInt(m[1], 10), M = parseInt(m[2], 10)-1, y = parseInt(m[3], 10);
  const dt = new Date(y, M, d);
  return isNaN(dt.getTime()) ? null : dt;
}


function __isDateLike_(v) {
  if (v == null) return false;
  if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v.getTime())) return true;
  // Si c’est du texte, on tente le parse (ex: "25/08/2025")
  if (typeof v === 'string') return !!toDateOrNull_(v);
  return false;
}


/************
  Synthèse – calcul
*************/



/** Génère la synthèse mensuelle des transports (non destructive). */

function genererSyntheseTransports(opts) {
  const t0 = Date.now();
  const def = getSyntheseDefaults_();
  const mois  = (opts && +opts.mois>=1 && +opts.mois<=12) ? +opts.mois : def.mois;
  const annee = (opts && +opts.annee) ? +opts.annee : def.annee;

  const ss = SpreadsheetApp.getActive();
  const sheets = [SHEET_CLIENTS, SHEET_PONCTUEL].map(n => ss.getSheetByName(n)).filter(Boolean);

  const totalMap   = new Map(); // client -> total
  const contratMap = new Map(); // client -> contrat
  let msRead = 0, msAgg = 0;

  sheets.forEach(sheet => {
    const tRead0 = Date.now();
    const lastRow = sheet.getLastRow();
    const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
    if (lastRow < 3 || lastCol < 3) return;

    const width  = lastCol - 2;         // C..lastCol
    const height = lastRow - 2;         // lignes données
    // Batch reads
    const valsAll = sheet.getRange(3, 3, height, width).getValues();           // dates (objets Date) – toutes lignes
    const dispAll = sheet.getRange(3, 3, height, width).getDisplayValues();    // affichages – toutes lignes
    const A_B     = sheet.getRange(3, 1, height, 2).getDisplayValues();        // A (Nom/Prénom), B (Contrat)
    const tRead1 = Date.now(); msRead += (tRead1 - tRead0);

    // Agrégation par blocs (2 lignes = 1 client)
    for (let r1rel = 0; r1rel < height; r1rel += NB_ROWS_BLOCK) {
      const r2rel = r1rel + 1; if (r2rel >= height) break;

      const nom    = String(A_B[r1rel][0] || '').trim();
      const prenom = String(A_B[r2rel][0] || '').trim();
      if (!nom) continue;
      const client  = prenom ? (nom + ' ' + prenom) : nom;

      const contrat = String(A_B[r1rel][1] || '').trim();
      if (contrat && !contratMap.has(client)) contratMap.set(client, contrat);

      const row1Vals = valsAll[r1rel];
      const row1Disp = dispAll[r1rel];
      const row2Disp = dispAll[r2rel];

      let sum = totalMap.get(client) || 0;
      for (let i = 0; i < width; i++) {
        const dv = row1Vals[i];
        if (dv && Object.prototype.toString.call(dv) === '[object Date]' && !isNaN(dv.getTime())) {
          if (dv.getFullYear() === annee && (dv.getMonth() + 1) === mois) {
            sum += extractTransportCount_(row1Disp[i]);
            sum += extractTransportCount_(row2Disp[i]);
          }
        }
      }
      totalMap.set(client, sum);
    }
    msAgg += (Date.now() - tRead1);
  });

  const lignes = Array.from(totalMap.entries())
    .map(([client, total]) => ({ client, contrat: contratMap.get(client) || '', total: total || 0 }))
    .sort((a, b) => a.client.localeCompare(b.client));

  const totalGlobal     = lignes.reduce((acc, x) => acc + (x.total || 0), 0);
  const nbClientsTotal  = lignes.length;
  const nbClientsActifs = lignes.filter(x => (x.total || 0) > 0).length;

  Logger.log(`[Synthèse] ${('0'+mois).slice(-2)}/${annee} — feuilles:${sheets.length}, read=${msRead}ms, agg=${msAgg}ms, total=${Date.now()-t0}ms, clients=${lignes.length}`);
  return { mois, annee, totalGlobal, lignes, nbClientsTotal, nbClientsActifs };
}


/************
  Outils feuilles (tailles & formats)
*************/

function ensureSheetHasAtLeast(sheet, minRows, minCols) {
  if (!sheet) return;
  const curRows = sheet.getMaxRows();
  const curCols = sheet.getMaxColumns();
  if (curRows < minRows) sheet.insertRowsAfter(curRows, minRows - curRows);
  if (curCols < minCols) sheet.insertColumnsAfter(curCols, minCols - curCols);
}
function ensureFrozenPanes_(sheet) {
  if (!sheet) return;
  try {
    if (sheet.getFrozenRows() !== 2)    sheet.setFrozenRows(2);
    if (sheet.getFrozenColumns() !== 2) sheet.setFrozenColumns(2);
  } catch (_) {}
}
function getNextStartRow(sheet) {
  const lr = sheet.getLastRow();
  return Math.max(3, lr + 1);
}

/************
  COPIE DES TEMPLATES
*************/
function copierTemplateEnteteOptim(targetSheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const template = ss.getSheetByName(SHEET_TEMPLATE_HEADER);
  if (!template) throw new Error('Feuille template en-tête introuvable: ' + SHEET_TEMPLATE_HEADER);

  ensureSheetHasAtLeast(targetSheet, 2, NB_COLS_BLOCK);

  const srcRange  = template.getRange(HEADER_RANGE);
  const destRange = targetSheet.getRange(HEADER_RANGE);
  srcRange.copyTo(destRange, SpreadsheetApp.CopyPasteType.PASTE_NORMAL,  false);
  srcRange.copyTo(destRange, SpreadsheetApp.CopyPasteType.PASTE_FORMAT,  false);

  ensureFrozenPanes_(targetSheet);
}
function copierTemplateClientOptim(targetSheet, startRow) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const template = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!template) throw new Error('Feuille template client introuvable: ' + SHEET_TEMPLATE_CLIENT);

  ensureSheetHasAtLeast(targetSheet, startRow + NB_ROWS_BLOCK - 1, NB_COLS_BLOCK);

  const srcRange  = template.getRange(CLIENT_RANGE);
  const destRange = targetSheet.getRange(startRow, 1, NB_ROWS_BLOCK, NB_COLS_BLOCK);
  srcRange.copyTo(destRange, SpreadsheetApp.CopyPasteType.PASTE_NORMAL, false);
  srcRange.copyTo(destRange, SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
}

/************
  Helpers – format
*************/
function appliquerFormatClientSurNb(tableSheet, startRow, nbClients) {
  if (nbClients <= 0) return;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const template = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  const srcRange = template.getRange(CLIENT_RANGE);
  ensureSheetHasAtLeast(tableSheet, startRow + nbClients * NB_ROWS_BLOCK - 1, NB_COLS_BLOCK);

  for (let i = 0; i < nbClients; i++) {
    const destRow   = startRow + i * NB_ROWS_BLOCK;
    const destRange = tableSheet.getRange(destRow, 1, NB_ROWS_BLOCK, NB_COLS_BLOCK);
    srcRange.copyTo(destRange, SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
  }
}
function alternerCouleursSimple(sheet, startRow, nbBlocs, nbCols) {
  if (nbBlocs <= 0) return;
  ensureSheetHasAtLeast(sheet, startRow + nbBlocs * NB_ROWS_BLOCK - 1, nbCols);
  const backgrounds = [];
  let toggle = false;
  for (let i = 0; i < nbBlocs; i++) {
    const color = toggle ? ALT_COLOR_GREY : ALT_COLOR_LIGHT;
    backgrounds.push(new Array(nbCols).fill(color)); // ligne 1
    backgrounds.push(new Array(nbCols).fill(color)); // ligne 2
    toggle = !toggle;
  }
  sheet.getRange(startRow, 1, nbBlocs * NB_ROWS_BLOCK, nbCols).setBackgrounds(backgrounds);
}
function blockAlternanceColor_(row1Abs) {
  const idx = Math.floor((row1Abs - 3) / NB_ROWS_BLOCK); // 0,1,2…
  return (idx % 2 === 0) ? ALT_COLOR_LIGHT : ALT_COLOR_GREY;
}
function setPlainTextNoValidation(range) {
  forcePlainText_(range);
  try { range.setDataValidation(null); } catch (_) {}
}

function appliquerValidationDatesPourColonnes_(sheet, cols, opts) {
  if (!cols || !cols.length) return;

  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  const lastRow = sheet.getLastRow();
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  const doublePass = !!(opts && opts.markAndReject);
  const { plages, yearRef } = getPlagesCachedForSheet_(sheet);

  // Ne garder que C..lastCol, distinctes et triées
  const colsOk = Array.from(new Set(
    cols.filter(c => c >= FIRST_DATA_COL && c <= lastCol)
  )).sort((a,b)=>a-b);

  colsOk.forEach(c => {
    const idx = c - FIRST_DATA_COL;
    const plage = plages[idx];
    const a1s = [];
    for (let r = FIRST_DATA_ROW; r <= lastRow; r += NB_ROWS_BLOCK) {
      a1s.push(sheet.getRange(r, c).getA1Notation());
    }
    const rl = sheet.getRangeList(a1s);

    if (!plage) {
      safeClearValidations_(rl);
      return;
    }

    const help = `Saisir une date entre ${
      Utilities.formatDate(plage.start, TZ, 'dd/MM/yyyy')
    } et ${
      Utilities.formatDate(plage.end, TZ, 'dd/MM/yyyy')
    }.`;

    const ruleWarn = SpreadsheetApp.newDataValidation()
      .requireDateBetween(plage.start, plage.end)
      .setAllowInvalid(true)
      .setHelpText(help)
      .build();

    const ruleReject = SpreadsheetApp.newDataValidation()
      .requireDateBetween(plage.start, plage.end)
      .setAllowInvalid(false)
      .setHelpText(help)
      .build();

    try {
      rl.setDataValidation(doublePass ? ruleWarn : ruleReject);
      if (doublePass) rl.setDataValidation(ruleReject);
    } catch (_) {
      rl.getRanges().forEach(r => r.setDataValidation(doublePass ? ruleWarn : ruleReject));
      if (doublePass) rl.getRanges().forEach(r => r.setDataValidation(ruleReject));
    }
  });
}


function getCurrentWeekCols_(sheet) {
  return computeWeekColsFromHeaders_(sheet, todayMidnight_()) || [];
}
function isCurrentWeekCol_(sheet, col) {
  const cols = getCurrentWeekCols_(sheet);
  for (let i = 0; i < cols.length; i++) if (cols[i] === col) return true;
  return false;
}







/************
  ÉCRITURE D’UN BLOC CLIENT
*************/
function writeClientBlock(sheet, startRow, data) {
  copierTemplateClientOptim(sheet, startRow);
  try { sheet.getRange(startRow + 1, COL_TEL).setNumberFormat('@'); } catch(_) {}
  sheet.getRange(startRow,     COL_NOM).setValue((data.nom || '').toString().toUpperCase());
  sheet.getRange(startRow,     COL_CONTRAT).setValue(data.contrat || '');
  sheet.getRange(startRow + 1, COL_PRENOM).setValue(capitalize(data.prenom || ''));
  sheet.getRange(startRow + 1, COL_TEL).setValue(formatTelephone(data.tel || ''));
  setPlainTextNoValidation(sheet.getRange(startRow, COL_CONTRAT));
  try { appliquerValidationDatesPourBloc_(sheet, startRow); } catch (_) {}
}

/************
  Ajout / Modif / Suppr
*************/
// Désactivation automatique (silencieuse) des prévisions
function desactiverPrevisionsAutoSiActives_() {
  if (!isForecastEnabled_()) return false;
  PropertiesService.getDocumentProperties().setProperty(PROP_FORECAST_ENABLED, '0');
  try { clearPrevisionsToutesFeuilles_(); } catch (e) { Logger.log(e); }
  return true;
}

function ajouterClientDialog() {
  const ui = SpreadsheetApp.getUi();
  const lock = LockService.getDocumentLock();
  if (!lock.tryLock(100)) { ui.alert('Veuillez patienter 2–3 secondes et réessayer.'); return; }
  try {
    const html = HtmlService.createHtmlOutputFromFile('ajouterClient').setWidth(400).setHeight(400);
    ui.showModalDialog(html, 'Ajouter un client ➕');
  } finally { try { lock.releaseLock(); } catch (_) {} }
}




/** Ajoute un client (2 lignes) sur la bonne feuille, trie et remet formats. */

function ajouterClient(data) {
  const lock = LockService.getDocumentLock();
  lock.waitLock(15000);

  // NEW: désactiver automatiquement les prévisions si actives
  desactiverPrevisionsAutoSiActives_();

  beginHighlightBatch_();
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const isPonctuel = (data.contrat || '').toUpperCase() === 'PONCTUEL';

    let sheet = ss.getSheetByName(isPonctuel ? SHEET_PONCTUEL : SHEET_CLIENTS);
    if (!sheet) sheet = ss.insertSheet(isPonctuel ? SHEET_PONCTUEL : SHEET_CLIENTS);

    copierTemplateEnteteOptim(sheet);

    const startRow = getNextStartRow(sheet);
    ensureSheetHasAtLeast(sheet, startRow + NB_ROWS_BLOCK - 1, NB_COLS_BLOCK);
    writeClientBlock(sheet, startRow, data);

    if (isPonctuel) trierFeuilleClientsPonctuels();
    else            trierClientsSansPonctuels();

    // Pas de réactivation auto
    resurlignerApresMaj_(sheet);
  } finally {
    try { endHighlightBatch_(); } catch(_) {}
    try { lock.releaseLock(); } catch(_) {}
  }
}



function formatTelephone(num) {
  return normalizePhoneForListing_(num);
}


function modifierClientDialog() {
  const ui = SpreadsheetApp.getUi();
  const lock = LockService.getDocumentLock();
  if (!lock.tryLock(100)) { ui.alert('Veuillez patienter 2–3 secondes et réessayer.'); return; }
  try {
    const html = HtmlService.createHtmlOutputFromFile('modifierClient').setWidth(400).setHeight(460);
    ui.showModalDialog(html, 'Modifier un client 🔄');
  } finally { try { lock.releaseLock(); } catch (_) {} }
}
function getListeClientsTous() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetsToCheck = [SHEET_CLIENTS, SHEET_PONCTUEL];
  let clients = [];

  sheetsToCheck.forEach(name => {
    const sheet = ss.getSheetByName(name);
    if (!sheet) return;
    const lastRow = sheet.getLastRow();
    if (lastRow < 3) return;

    const values = sheet.getRange(3, 1, lastRow - 2, 2).getValues(); // A..B
    for (let i = 0; i < values.length; i += 2) {
      const r1 = values[i];           // [NOM, CONTRAT]
      const r2 = values[i + 1] || []; // [PRÉNOM, TÉL]
      const nom = (r1 && r1[0]) ? r1[0].toString().trim() : '';
      const prenom = (r2 && r2[0]) ? r2[0].toString().trim() : '';
      if (nom) clients.push(prenom ? `${nom} ${prenom}` : nom);
    }
  });

  clients.sort((a, b) => a.localeCompare(b));
  return clients;
}
function getClientDataTous(nomComplet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const feuilles = [SHEET_CLIENTS, SHEET_PONCTUEL];
  const target = (nomComplet || '').trim().toLowerCase();

  for (let feuille of feuilles) {
    const sheet = ss.getSheetByName(feuille);
    if (!sheet) continue;
    const lastRow = sheet.getLastRow();
    if (lastRow < 3) continue;

    const nbCols = Math.max(4, sheet.getLastColumn());
    const data = sheet.getRange(3, 1, lastRow - 2, nbCols).getValues();

    for (let i = 0; i < data.length; i += 2) {
      const r1 = data[i], r2 = data[i + 1] || [];
      const nom    = (r1[0] || '').toString().trim();
      const prenom = (r2[0] || '').toString().trim();
      const full   = (nom + (prenom ? ' ' + prenom : '')).toLowerCase();
      if (full === target) {
        const row1Abs = 3 + i;
        const telDisplay = sheet.getRange(row1Abs + 1, COL_TEL).getDisplayValue();
        return { nom, prenom, tel: telDisplay || '', contrat: r1[1] || '' };
      }
    }
  }
  return null;
}
function deplacerBlocClientAvecDonnees_(srcSheet, row1Abs, destSheet) {
  copierTemplateEnteteOptim(destSheet);
  const startRow = getNextStartRow(destSheet);
  ensureSheetHasAtLeast(destSheet, startRow + NB_ROWS_BLOCK - 1, NB_COLS_BLOCK);

  srcSheet
    .getRange(row1Abs, 1, NB_ROWS_BLOCK, NB_COLS_BLOCK)
    .copyTo(destSheet.getRange(startRow, 1, NB_ROWS_BLOCK, NB_COLS_BLOCK),
            SpreadsheetApp.CopyPasteType.PASTE_NORMAL, false);

  setPlainTextNoValidation(destSheet.getRange(startRow, COL_CONTRAT));
  try { destSheet.getRange(startRow + 1, COL_TEL).setNumberFormat('@'); } catch(_) {}

  return startRow;
}


/** Modifie un client ; gère le passage régulier ↔ ponctuel si besoin. */

function modifierClient(data) {
  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  // NEW: désactiver automatiquement les prévisions si actives
  desactiverPrevisionsAutoSiActives_();

  beginHighlightBatch_();
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetsToCheck = [SHEET_CLIENTS, SHEET_PONCTUEL];
    const target = (data.oldNom || '').trim().toLowerCase();
    const newIsPonctuel = (data.contrat || '').toUpperCase() === 'PONCTUEL';

    let foundSheet = null, foundRow1 = null;
    for (let sheetName of sheetsToCheck) {
      const sheet = ss.getSheetByName(sheetName);
      if (!sheet) continue;
      const lastRow = sheet.getLastRow();
      if (lastRow < 3) continue;

      const values = sheet.getRange(3, 1, lastRow - 2, 2).getValues();
      for (let i = 0; i < values.length; i += 2) {
        const nom    = (values[i][0] || '').toString().trim();
        const prenom = (values[i + 1] && values[i + 1][0]) ? values[i + 1][0].toString().trim() : '';
        const full   = (nom + (prenom ? ' ' + prenom : '')).toLowerCase();
        if (full === target) { foundSheet = sheet; foundRow1 = 3 + i; break; }
      }
      if (foundSheet) break;
    }

    if (!foundSheet || !foundRow1) throw new Error("Client introuvable.");
    const wasPonctuel = (foundSheet.getName() === SHEET_PONCTUEL);

    const toHighlight = new Set();

    if (wasPonctuel !== newIsPonctuel) {
      // ====== CHANGEMENT DE FEUILLE (ponctuel <-> régulier) ======
      let dest = ss.getSheetByName(newIsPonctuel ? SHEET_PONCTUEL : SHEET_CLIENTS);
      if (!dest) dest = ss.insertSheet(newIsPonctuel ? SHEET_PONCTUEL : SHEET_CLIENTS);

      const newRow1 = deplacerBlocClientAvecDonnees_(foundSheet, foundRow1, dest);

      // Mise à jour des 4 champs en 2x2 (NOM/CONTRAT sur ligne 1, PRÉNOM/TEL sur ligne 2)
      ensureSheetHasAtLeast(dest, newRow1 + 1, NB_COLS_BLOCK);
      try { dest.getRange(newRow1 + 1, COL_TEL).setNumberFormat('@'); } catch(_) {}

      const values2x2 = [
        [ (data.nom || '').toString().toUpperCase(),         data.contrat || '' ],
        [ capitalize(data.prenom || ''),                     formatTelephone(data.tel || '') ]
      ];
      dest.getRange(newRow1, 1, 2, 2).setValues(values2x2);
      setPlainTextNoValidation(dest.getRange(newRow1, COL_CONTRAT));

      // Supprime l’ancien bloc
      foundSheet.deleteRows(foundRow1, NB_ROWS_BLOCK);

      // Tris (on garde ta logique : on retrie les deux feuilles)
      trierFeuilleClientsPonctuels();
      trierClientsSansPonctuels();

      // ⚡ Validations ciblées uniquement sur le NOUVEAU bloc
      appliquerValidationDatesPourBloc_(dest, newRow1);

      toHighlight.add(dest);
      toHighlight.add(foundSheet);

    } else {
      // ====== MÊME FEUILLE ======
      ensureSheetHasAtLeast(foundSheet, foundRow1 + 1, NB_COLS_BLOCK);
      try { foundSheet.getRange(foundRow1 + 1, COL_TEL).setNumberFormat('@'); } catch(_) {}

      const values2x2 = [
        [ (data.nom || '').toString().toUpperCase(),         data.contrat || '' ],
        [ capitalize(data.prenom || ''),                     formatTelephone(data.tel || '') ]
      ];
      foundSheet.getRange(foundRow1, 1, 2, 2).setValues(values2x2);
      setPlainTextNoValidation(foundSheet.getRange(foundRow1, COL_CONTRAT));

      if (newIsPonctuel) trierFeuilleClientsPonctuels();
      else               trierClientsSansPonctuels();

      // ⚡ Validations ciblées uniquement sur ce bloc
      appliquerValidationDatesPourBloc_(foundSheet, foundRow1);

      toHighlight.add(foundSheet);
    }

    // Surbrillance différée
    toHighlight.forEach(sh => resurlignerApresMaj_(sh));

  } finally {
    try { endHighlightBatch_(); } catch(_) {}
    try { lock.releaseLock(); } catch(_) {}
  }
}

function supprimerClientDialog() {
  const ui = SpreadsheetApp.getUi();
  const lock = LockService.getDocumentLock();
  if (!lock.tryLock(100)) { ui.alert('Veuillez patienter 2–3 secondes et réessayer.'); return; }
  try {
    const html = HtmlService.createHtmlOutputFromFile('supprimerClient').setWidth(520).setHeight(260);
    ui.showModalDialog(html, 'Supprimer un client ❌');
  } catch (e) {
    ui.alert('Ouverture impossible','Vérifie le fichier "supprimerClient.html".\n\nDétails : ' + ((e && e.message) || e), ui.ButtonSet.OK);
  } finally { try { lock.releaseLock(); } catch (_) {} }
}



/** Supprime un client sur l’ensemble des feuilles. */

function supprimerClientTous(fullName) {
  const lock = LockService.getDocumentLock();
  lock.waitLock(15000);

  // NEW: désactiver automatiquement les prévisions si actives
  desactiverPrevisionsAutoSiActives_();

  beginHighlightBatch_();
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetsToCheck = [SHEET_CLIENTS, SHEET_PONCTUEL];
    const target = (fullName || '').trim().toLowerCase();

    let deleted = false;
    let deletedSheet = null;

    for (const name of sheetsToCheck) {
      const sheet = ss.getSheetByName(name);
      if (!sheet) continue;

      const lastRow = sheet.getLastRow();
      if (lastRow < 3) continue;

      const values = sheet.getRange(3, 1, lastRow - 2, 2).getValues();
      for (let i = 0; i < values.length; i += 2) {
        const nom = (values[i][0] || '').toString().trim();
        const prenom = (values[i + 1] && values[i + 1][0]) ? values[i + 1][0].toString().trim() : '';
        const full = (nom + (prenom ? ' ' + prenom : '')).toLowerCase();

        if (full === target) {
          const row1 = 3 + i;
          sheet.deleteRows(row1, NB_ROWS_BLOCK);
          deleted = true;
          deletedSheet = sheet;
          break;
        }
      }
      if (deleted) break;
    }

    // ⚡ Ne trie QUE la feuille impactée
    if (deletedSheet) {
      if (deletedSheet.getName() === SHEET_PONCTUEL) {
        trierFeuilleClientsPonctuels();
      } else {
        trierClientsSansPonctuels();
      }
      // Surbrillance sur la feuille modifiée
      resurlignerApresMaj_(deletedSheet);
    }

  } finally {
    try { endHighlightBatch_(); } catch(_) {}
    try { lock.releaseLock(); } catch(_) {}
  }
}


/************
  Tri
*************/

function trierClientsSansPonctuels() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEET_CLIENTS);
  if (!sheet) return;
  const lastRow = sheet.getLastRow();
  if (lastRow <= 2) return;

  const nbCols = Math.max(NB_COLS_BLOCK, sheet.getLastColumn());
  const data = sheet.getRange(3, 1, lastRow - 2, nbCols).getValues();

  let blocs = [];
  for (let i = 0; i < data.length; i += 2) {
    const r1 = data[i];
    const r2 = data[i + 1] || new Array(nbCols).fill('');
    if (!r1) continue;
    if ((r1[1] || '').toString().toUpperCase() !== 'PONCTUEL') {
      blocs.push([r1, r2]);
    }
  }

  blocs.sort((a, b) => {
    if ((a[0][0] || '') === (b[0][0] || '')) return (a[1][0] || '').localeCompare(b[1][0] || '');
    return (a[0][0] || '').localeCompare(b[0][0] || '');
  });

  let out = [];
  blocs.forEach(b => { out.push(b[0]); out.push(b[1]); });

  const startRow = 3;
  if (out.length > 0) {
    ensureSheetHasAtLeast(sheet, startRow + out.length - 1, nbCols);
    sheet.getRange(startRow, 1, out.length, nbCols).setValues(out);
  } else {
    if (lastRow > 2) sheet.getRange(3, 1, lastRow - 2, nbCols).clearContent().clearFormat();
  }

  let lastWrittenRow = startRow + out.length - 1;
  if (lastWrittenRow < 2) lastWrittenRow = 2;
  if (lastRow > lastWrittenRow) {
    sheet.getRange(lastWrittenRow + 1, 1, lastRow - lastWrittenRow, nbCols).clearContent().clearFormat();
  }

  const nbClients = blocs.length;
  if (nbClients > 0) appliquerFormatClientSurNb(sheet, startRow, nbClients);
  if (nbClients > 0) alternerCouleursSimple(sheet, startRow, nbClients, nbCols);
}
function trierFeuilleClientsPonctuels() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(SHEET_PONCTUEL);
  if (!sheet) sheet = ss.insertSheet(SHEET_PONCTUEL);

  copierTemplateEnteteOptim(sheet);

  const lastRow = sheet.getLastRow();
  if (lastRow <= 2) return;

  const nbCols = Math.max(NB_COLS_BLOCK, sheet.getLastColumn());
  const data = sheet.getRange(3, 1, lastRow - 2, nbCols).getValues();

  let blocs = [];
  for (let i = 0; i < data.length; i += 2) {
    const r1 = data[i];
    const r2 = data[i + 1] || new Array(nbCols).fill('');
    if (!r1) continue;
    blocs.push([r1, r2]);
  }

  blocs.sort((a, b) => {
    if ((a[0][0] || '') === (b[0][0] || '')) return (a[1][0] || '').localeCompare(b[1][0] || '');
    return (a[0][0] || '').localeCompare(b[0][0] || '');
  });

  let out = [];
  blocs.forEach(b => { out.push(b[0]); out.push(b[1]); });

  const startRow = 3;
  if (out.length > 0) {
    ensureSheetHasAtLeast(sheet, startRow + out.length - 1, nbCols);
    sheet.getRange(startRow, 1, out.length, nbCols).setValues(out);
  } else {
    if (lastRow > 2) sheet.getRange(3, 1, lastRow - 2, nbCols).clearContent().clearFormat();
  }

  const nbClients = blocs.length;
  if (nbClients > 0) appliquerFormatClientSurNb(sheet, startRow, nbClients);
  if (nbClients > 0) alternerCouleursSimple(sheet, startRow, nbClients, nbCols);
}

/************
  UTILS
*************/

function capitalize(str) { if (!str) return ''; return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase(); }

/************
  MENUS RESYNCHRO + FORMAT TEMPLATES
*************/

function resynchroniserTemplatesMenu() {
  const ui = SpreadsheetApp.getUi();
  const resp = ui.alert(
    'Resynchroniser les templates',
    `Cette opération va réappliquer UNIQUEMENT les formats (et tailles) des templates sur "${SHEET_CLIENTS}" et "${SHEET_PONCTUEL}". Aucune donnée ne sera modifiée.\n\nContinuer ?`,
    ui.ButtonSet.YES_NO
  );
  if (resp !== ui.Button.YES) return;

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  ss.toast('Resynchronisation en cours...', 'Gestion client', 5);
  try {
    resynchroniserTemplatesToutesFeuilles();

    const shClients   = ss.getSheetByName(SHEET_CLIENTS);
    const shPonctuel  = ss.getSheetByName(SHEET_PONCTUEL);
    resurlignerApresMaj_(shClients);
    resurlignerApresMaj_(shPonctuel);

    ss.toast('Resynchronisation terminée ✅', 'Gestion client', 5);
    ui.alert('Terminé ✅', 'Les feuilles ont été resynchronisées (formats/tailles) sans altérer les données.', ui.ButtonSet.OK);
  } catch (e) {
    ss.toast('Erreur durant la resynchronisation ❌', 'Gestion client', 5);
    ui.alert('Erreur', String(e && e.message ? e.message : e), ui.ButtonSet.OK);
  }
}
function resynchroniserTemplatesToutesFeuilles() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
    let sh = ss.getSheetByName(name);
    if (!sh) sh = ss.insertSheet(name);
    copierTemplateEnteteOptim(sh);
  });

  resynchroniserFeuilleAvecTemplates(SHEET_CLIENTS);
  resynchroniserFeuilleAvecTemplates(SHEET_PONCTUEL);

  // ⬇️ Ajoute ceci pour pousser les listes "Statut" (dont "1/2 Transport 🚛") à tous les blocs :
  resynchroniserValidationsStatutDepuisTemplate();

  appliquerValidationsToutesFeuilles(); // (dates)
}

function reappliquerFormatBlocSansChangerValeurs(sheet, row1Abs, templateClientSheet) {
  ensureSheetHasAtLeast(sheet, row1Abs + NB_ROWS_BLOCK - 1, NB_COLS_BLOCK);
  templateClientSheet.getRange(CLIENT_RANGE)
    .copyTo(sheet.getRange(row1Abs, 1, NB_ROWS_BLOCK, NB_COLS_BLOCK), SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
  setPlainTextNoValidation(sheet.getRange(row1Abs, COL_CONTRAT));
  try { sheet.getRange(row1Abs + 1, COL_TEL).setNumberFormat('@'); } catch(_) {}
}
function resynchroniserFeuilleAvecTemplates(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return;

  const templateHeader = ss.getSheetByName(SHEET_TEMPLATE_HEADER);
  const templateClient = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!templateHeader || !templateClient) throw new Error('Templates introuvables.');

  copierTemplateEnteteOptim(sheet);

  try { sheet.getRange(1, COL_CONTRAT, sheet.getMaxRows(), 1).setDataValidation(null); } catch (_) {}

  syncColonnesDepuisTemplate(sheet, templateClient, NB_COLS_BLOCK);
  syncHauteursDepuisTemplates(sheet, templateHeader, templateClient);

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) return;

  const nbCols = Math.max(NB_COLS_BLOCK, sheet.getLastColumn());
  const data = sheet.getRange(3, 1, lastRow - 2, nbCols).getValues();

  let nbBlocsUtilises = 0;
  for (let i = 0; i < data.length; i += 2) {
    const r1 = data[i] || [];
    const r2 = data[i + 1] || [];
    const hasData = (r1.some(v => v !== '' && v !== null) || r2.some(v => v !== '' && v !== null));
    if (!hasData) continue;

    const row1Abs = 3 + i;
    reappliquerFormatBlocSansChangerValeurs(sheet, row1Abs, templateClient);
    nbBlocsUtilises++;
  }

  if (nbBlocsUtilises > 0) {
    alternerCouleursSimple(sheet, 3, nbBlocsUtilises, Math.max(NB_COLS_BLOCK, sheet.getLastColumn()));
  }
  ensureFrozenPanes_(sheet);
  resurlignerApresMaj_(sheet);
}
function syncColonnesDepuisTemplate(targetSheet, templateClientSheet, nbCols) {
  ensureSheetHasAtLeast(targetSheet, targetSheet.getMaxRows(), nbCols);
  for (let c = 1; c <= nbCols; c++) {
    const w = templateClientSheet.getColumnWidth(c);
    targetSheet.setColumnWidth(c, w);
  }
}
function syncHauteursDepuisTemplates(targetSheet, templateHeaderSheet, templateClientSheet) {
  ensureSheetHasAtLeast(targetSheet, 2, targetSheet.getMaxColumns());
  try {
    const h1 = templateHeaderSheet.getRowHeight(1);
    const h2 = templateHeaderSheet.getRowHeight(2);
    targetSheet.setRowHeight(1, h1);
    targetSheet.setRowHeight(2, h2);
  } catch (e) { /* ignore */ }

  const lastRow = targetSheet.getLastRow();
  if (lastRow < 3) return;

  let hc1 = null, hc2 = null;
  try { hc1 = templateClientSheet.getRowHeight(1); hc2 = templateClientSheet.getRowHeight(2); } catch (e) {}

  if (hc1 || hc2) {
    for (let r = 3; r <= lastRow; r += 2) {
      if (hc1) targetSheet.setRowHeight(r, hc1);
      if (r + 1 <= lastRow && hc2) targetSheet.setRowHeight(r + 1, hc2);
    }
  }
}


function __normStatut_(s) {
  return String(s || '')
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // accents
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\p{P}\p{S}]/gu, ' ') // ponctuation & symboles (dont emojis)
    .replace(/\s+/g, ' ').trim();
}

// Lit la 1re règle "liste d’items" sur la ligne 2 du template et renvoie {items[], mapNorm->canonique}
function __buildCanonStatutsFromTemplate_(tpl, width) {
  const rulesRow = tpl.getRange(2, FIRST_DATA_COL, 1, width).getDataValidations()[0] || [];
  let items = null;
  for (let j = 0; j < rulesRow.length; j++) {
    const rule = rulesRow[j];
    if (!rule) continue;
    if (rule.getCriteriaType && rule.getCriteriaType() === SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST) {
      const vals = rule.getCriteriaValues && rule.getCriteriaValues();
      if (vals && vals[0] && vals[0].length) { items = vals[0].slice(); break; }
    }
  }
  if (!items) return null;

  const map = new Map();
  items.forEach(v => map.set(__normStatut_((v || '')), String(v || '')));
  return { items, map };
}

// Parcourt toutes les cellules Statut (ligne 2 des blocs) et remplace les textes proches par l’option canonique
function normaliserStatutsExistantsSelonTemplate_(sheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const tpl = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!tpl) return;

  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  const lastRow = sheet.getLastRow();
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  const width = lastCol - FIRST_DATA_COL + 1;
  const canon = __buildCanonStatutsFromTemplate_(tpl, width);
  if (!canon) return;

  for (let r1 = FIRST_DATA_ROW; r1 <= lastRow; r1 += NB_ROWS_BLOCK) {
    const r2 = r1 + 1; if (r2 > lastRow) break;

    const disp = sheet.getRange(r2, FIRST_DATA_COL, 1, width).getDisplayValues()[0];
    const out  = disp.slice();
    let dirty = false;

    for (let j = 0; j < width; j++) {
      const cur = String(disp[j] || '').trim();
      if (!cur) continue;
      const key = __normStatut_(cur);
      const canonVal = canon.map.get(key);
      if (canonVal && cur !== canonVal) { out[j] = canonVal; dirty = true; }
    }
    if (dirty) sheet.getRange(r2, FIRST_DATA_COL, 1, width).setValues([out]);
  }
}





/************
  Validations (dates)
*************/




// Re-applique le FORMAT (fond, couleur police, alignements, etc.) des cellules "Statut"
// depuis le template, sur la LIGNE 2 de chaque bloc, pour C..BB,
// en évitant certaines colonnes (ex: la semaine en cours).
function reappliquerFormatStatutDepuisTemplate_(sheet, opts) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const tpl = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!tpl) return;

  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  const lastRow = sheet.getLastRow();
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  const excludeCols = new Set((opts && opts.excludeCols) || []);

  // Colonnes à traiter = C..lastCol sauf exclusions
  const cols = [];
  for (let c = FIRST_DATA_COL; c <= lastCol; c++) {
    if (!excludeCols.has(c)) cols.push(c);
  }
  if (!cols.length) return;

  // Segments contigus pour limiter les copyTo
  const runs = (function toRuns(arr){
    const a = Array.from(new Set(arr)).sort((x,y)=>x-y);
    if (!a.length) return [];
    const out=[]; let s=a[0], p=a[0];
    for (let i=1;i<a.length;i++){ if (a[i]===p+1){ p=a[i]; continue; } out.push([s,p]); s=p=a[i]; }
    out.push([s,p]); return out;
  })(cols);

  runs.forEach(([c1,c2]) => {
    const w = c2 - c1 + 1;
    const src = tpl.getRange(2, c1, 1, w); // ligne 2 du template = "Statut"
    for (let r1 = FIRST_DATA_ROW; r1 <= lastRow; r1 += NB_ROWS_BLOCK) {
      const r2 = r1 + 1; if (r2 > lastRow) break;
      // PASTE_FORMAT = on ne touche pas aux valeurs
      src.copyTo(sheet.getRange(r2, c1, 1, w), SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
    }
  });
}



function resynchroniserValidationsStatutDepuisTemplate() {
  const ss  = SpreadsheetApp.getActiveSpreadsheet();
  const tpl = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!tpl) throw new Error('Feuille template client introuvable: ' + SHEET_TEMPLATE_CLIENT);

  beginHighlightBatch_();
  try {
    [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(n => {
      const sh = ss.getSheetByName(n);
      if (!sh) return;

      // 1) Repose la validation "Statut" en conservant les couleurs des options
      copyStatusValidationsFromTemplateToSheet_(tpl, sh);

      // 2) Convertit les textes existants vers les options canoniques → réactive les puces colorées
      normaliserStatutsExistantsSelonTemplate_(sh);

      // 3) Repeint alternance + semaine en cours (+ prévisions si actives)
      resurlignerApresMaj_(sh);
    });
    ss.toast('Validations "Statut" + couleurs restaurées ✅', 'Gestion client', 4);
  } finally {
    endHighlightBatch_();
  }
}


function copyStatusValidationsFromTemplateToSheet_(templateSheet, targetSheet) {
  const lastCol = Math.min(NB_COLS_BLOCK, targetSheet.getLastColumn());
  const lastRow = targetSheet.getLastRow();
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  // On copie la LIGNE 2 du template (C..lastCol) en "PASTE_DATA_VALIDATION"
  const width = lastCol - FIRST_DATA_COL + 1;
  const src = templateSheet.getRange(2, FIRST_DATA_COL, 1, width);

  for (let r1 = FIRST_DATA_ROW; r1 <= lastRow; r1 += NB_ROWS_BLOCK) {
    const r2 = r1 + 1; if (r2 > lastRow) break;
    const dest = targetSheet.getRange(r2, FIRST_DATA_COL, 1, width);
    // ⬇️ Très important : garde les couleurs/options des Dropdown chips
    src.copyTo(dest, SpreadsheetApp.CopyPasteType.PASTE_DATA_VALIDATION, false);
  }
}



function appliquerValidationsToutesFeuilles() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
    const sh = ss.getSheetByName(name);
    if (sh) appliquerValidationDatesSurFeuille_(sh);
  });
  ss.toast('Validations des dates mises à jour ✅', 'Gestion client', 4);
}
function recalculerValidationsDepuisMenu() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
    const sh = ss.getSheetByName(name);
    if (sh) appliquerValidationDatesSurFeuille_(sh, { markAndReject: true });
  });
  ss.toast('Validations recalculées (erreurs marquées) ✅', 'Gestion client', 5);
}
function appliquerValidationDatesSurFeuille_(sheet, opts) {
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastCol < FIRST_DATA_COL) return;
  const cols = [];
  for (let c = FIRST_DATA_COL; c <= lastCol; c++) cols.push(c);
  appliquerValidationDatesPourColonnes_(sheet, cols, opts);
}


function getAnneeDeReference_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('Paramètres');
  if (!sh) return new Date().getFullYear();
  const y = Number(sh.getRange('B1').getValue());
  return (y && !isNaN(y)) ? y : new Date().getFullYear();
}
function parsePlageDepuisEntete_(texte, anneeRef) {
  if (!texte) return null;
  const s = ('' + texte).trim()
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/\./g, '');
  const re = /du\s*(\d{1,2})(?:\s*([a-z]+))?(?:\s*(\d{4}))?\s*au\s*(\d{1,2})(?:\s*([a-z]+))?(?:\s*(\d{4}))?$/i;
  const m = s.match(re);
  if (!m) return null;

  const d1 = parseInt(m[1], 10);
  const m1Name = m[2] || null;
  const y1Exp = m[3] ? parseInt(m[3], 10) : null;

  const d2 = parseInt(m[4], 10);
  const m2Name = m[5] || null;
  const y2Exp = m[6] ? parseInt(m[6], 10) : null;

  let mi2 = (m2Name ? moisNomVersIndex_(m2Name) : null);
  let mi1 = (m1Name ? moisNomVersIndex_(m1Name) : null);

  let y2 = y2Exp || anneeRef;
  let y1 = y1Exp || y2;

  if (mi2 != null && mi1 == null) {
    if (d1 > d2) { mi1 = (mi2 + 11) % 12; if (mi2 === 0) y1 = y2 - 1; }
    else { mi1 = mi2; }
  }
  if (mi1 != null && mi2 == null) {
    if (d2 < d1) { mi2 = (mi1 + 1) % 12; if (mi1 === 11) y2 = y1 + 1; }
    else { mi2 = mi1; }
  }
  if (mi1 != null && mi2 != null) {
    if (y1Exp == null && y2Exp == null) {
      if (mi1 > mi2) y1 = y2 - 1;
    } else if (y1Exp == null && y2Exp != null) {
      if (mi1 > mi2) y1 = y2 - 1; else y1 = y2;
    } else if (y1Exp != null && y2Exp == null) {
      y2 = y1; if (mi2 < mi1) y2 = y1 + 1;
    }
  }
  if (mi1 != null && mi2 != null && y1 != null && y2 != null) {
    if (y1 === y2 && mi1 === mi2 && d1 > d2) {
      mi1 = (mi2 + 11) % 12; if (mi2 === 0) y1 = y2 - 1;
    }
  }
  if (mi1 == null || mi2 == null) return null;

  const start = new Date(y1, mi1, d1);
  const end   = new Date(y2, mi2, d2, 23, 59, 59, 999);
  if (isNaN(start.getTime()) || isNaN(end.getTime())) return null;
  return { start, end };
}
function moisNomVersIndex_(m) {
  const map = {
    'janvier':0, 'janv':0, 'jan':0,
    'fevrier':1, 'fevr':1, 'fev':1,
    'mars':2, 'avril':3, 'avr':3, 'mai':4, 'juin':5,
    'juillet':6, 'juil':6,
    'aout':7, 'aou':7, 'ao':7,
    'septembre':8, 'sept':8, 'sep':8,
    'octobre':9, 'oct':9, 'novembre':10, 'nov':10,
    'decembre':11, 'dec':11
  };
  return (m in map) ? map[m] : null;
}

/************
  onEdit : reposer validations (léger)
*************/
function onEdit(e) {
  try {
    if (!e || !e.range) return;
    const sh = e.range.getSheet();
    const name = sh.getName();

    // ➕ Préremplir "Statut" quand la Date passe de vide → rempli
    maybePrefillStatutWhenDateFirstSet_(e);

    // ... le reste de ton onEdit (inchangé) ...
    maybeClearForecastColorOnEdit_(e);
    maybeRepaintForecastOnClear_(e);
    if ((name === SHEET_CLIENTS || name === SHEET_PONCTUEL)) {
      const c0 = e.range.getColumn();
      const w  = e.range.getNumColumns();
      const lastCol = Math.min(NB_COLS_BLOCK, sh.getLastColumn());
      const touched = [];
      for (let c = c0; c < c0 + w; c++) {
        if (c >= FIRST_DATA_COL && c <= lastCol) touched.push(c);
      }
      if (touched.length) appliquerValidationDatesPourColonnes_(sh, touched);
    }
    maybeRepaintS1WhenCurrentWeekEdited_(e);
    maybeKeepCurrentWeekBlueOnEdit_(e);

  } catch (err) { Logger.log(err); }
}





/************
  Validation pour un SEUL bloc (ajout)
*************/
function appliquerValidationDatesPourBloc_(sheet, row1) {
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastCol < FIRST_DATA_COL) return;

  const annee = getAnneeDeReference_();
  const headers = sheet
    .getRange(HEADER_ROWS, FIRST_DATA_COL, 1, lastCol - (FIRST_DATA_COL - 1))
    .getDisplayValues()[0];

  for (let c = FIRST_DATA_COL; c <= lastCol; c++) {
    const txt  = headers[c - FIRST_DATA_COL] || '';
    const cell = sheet.getRange(row1, c);

    if (!txt) { cell.setDataValidation(null); continue; }

    const plage = parsePlageDepuisEntete_(txt, annee);
    if (!plage) { cell.setDataValidation(null); continue; }

    const help = `Saisir une date entre ${
      Utilities.formatDate(plage.start, TZ, 'dd/MM/yyyy')
    } et ${
      Utilities.formatDate(plage.end, TZ, 'dd/MM/yyyy')
    }.`;

    const rule = SpreadsheetApp.newDataValidation()
      .requireDateBetween(plage.start, plage.end)
      .setAllowInvalid(false)
      .setHelpText(help)
      .build();

    cell.setDataValidation(rule);
  }
}



/************
  SURBRILLANCE – Semaine en cours (bleue)
*************/
function todayMidnight_() {
  const tz = Session.getScriptTimeZone() || 'Europe/Paris';
  const now = new Date();
  const y = Utilities.formatDate(now, tz, 'yyyy');
  const m = Utilities.formatDate(now, tz, 'MM');
  const d = Utilities.formatDate(now, tz, 'dd');
  return new Date(Number(y), Number(m)-1, Number(d), 0, 0, 0, 0);
}



function surlignerSemaineEnCoursToutesFeuilles_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const today = todayMidnight_();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
    const sh = ss.getSheetByName(name);
    if (!sh) return;
    mettreEnValeurColonneJourSurFeuille_(sh, today);
    if (isForecastEnabled_()) {
      clearPrevisionsSurFeuille_(sh);
      appliquerPrevisionsSurFeuille_(sh);
      try { appliquerMasquageS1SurFeuille_(sh); } catch(_){}
    }
  });
}



function restaurerFormatsEntete_(sheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const tmpl = ss.getSheetByName(SHEET_TEMPLATE_HEADER);
  if (!tmpl) return;
  try {
    tmpl.getRange(HEADER_RANGE)
        .copyTo(sheet.getRange(HEADER_RANGE), SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
  } catch(_) {}
}



function mettreEnValeurColonneJourSurFeuille_(sheet, targetDate) {
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  const lastRow = sheet.getLastRow();
  if (lastCol < FIRST_DATA_COL || lastRow < 1) return;

  const { plages } = getPlagesCachedForSheet_(sheet);
  const width = Math.min(plages.length, lastCol - (FIRST_DATA_COL - 1));

  const d = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
  const targetCols = [];
  for (let j = 0; j < width; j++) {
    const p = plages[j]; if (!p) continue;
    const s = new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate());
    const e = new Date(p.end.getFullYear(),   p.end.getMonth(),   p.end.getDate());
    if (d >= s && d <= e) targetCols.push(FIRST_DATA_COL + j);
  }

  const props   = PropertiesService.getDocumentProperties();
  const key     = PROP_WEEK_BORDER_COLS_PREFIX + sheet.getSheetId();
  const key2    = PROP_WEEK_LAST_ROWS_PREFIX  + sheet.getSheetId();
  const prev    = (props.getProperty(key) || '').split(',').map(s => parseInt(s, 10)).filter(n => !isNaN(n));
  const prevRows = parseInt(props.getProperty(key2) || '0', 10);

  const sameCols = prev.length === targetCols.length && prev.every((v, i) => v === targetCols[i]);
  if (sameCols && prevRows === lastRow) return;

  // Remise alternance blocs (gris/blanc)
  if (lastRow >= FIRST_DATA_ROW) {
    const nbBlocs = Math.floor((lastRow - (FIRST_DATA_ROW - 1)) / NB_ROWS_BLOCK);
    if (nbBlocs > 0) alternerCouleursSimple(sheet, FIRST_DATA_ROW, nbBlocs, Math.max(NB_COLS_BLOCK, sheet.getLastColumn()));
  }

  const height = Math.max(HEADER_ROWS, lastRow);

  // 1) Nettoyage COMPLET des anciennes colonnes surlignées (y compris les bordures bleues verticales)
  prev.forEach(col => {
    if (col < FIRST_DATA_COL || col > lastCol || targetCols.indexOf(col) !== -1) return;

    // Efface toutes les bordures (entête + corps)
    sheet.getRange(1, col, height, 1)
         .setBorder(false, false, false, false, false, false, null, null);

    // Restaure le format des blocs depuis le template
    reappliquerFormatColonneDepuisTemplatePourBlocs_(sheet, col);
  });

  // 2) Restaure l’en-tête (remet les bordures/format "noirs")
  restaurerFormatsEntete_(sheet);

  // 3) Si aucune colonne à surligner, mémorise & quitte
  if (targetCols.length === 0) {
    props.deleteProperty(key);
    props.setProperty(key2, String(lastRow));
    return;
  }

  // 4) Applique la mise en valeur sur la semaine courante (bordures bleues + fonds)
  targetCols.forEach(col => {
    // Bordures verticales (colonne complète)
    sheet.getRange(1, col, height, 1).setBorder(
      null, /*left*/ true, null, /*right*/ true, null, null,
      HIGHLIGHT_BORDER_COLOR, HIGHLIGHT_BORDER_STYLE
    );

    // Entêtes (deux lignes)
    const headRange = sheet.getRange(1, col, HEADER_ROWS, 1);
    headRange
      .setBackground(HIGHLIGHT_HEADER_BG)
      .setFontWeight('bold')
      .setFontColor(HIGHLIGHT_HEADER_TEXT);

    // Corps (fond bleu clair)
    if (height > HEADER_ROWS) {
      sheet.getRange(FIRST_DATA_ROW, col, height - HEADER_ROWS, 1)
           .setBackground(HIGHLIGHT_COLUMN_BG);
    }
  });

  // 5) Mémorisation état
  props.setProperty(key,  targetCols.join(','));
  props.setProperty(key2, String(lastRow));
}




function reappliquerFormatColonneDepuisTemplatePourBlocs_(sheet, col) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const templateClient = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  if (!templateClient) return;

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) return;

  const nbCols = Math.max(NB_COLS_BLOCK, sheet.getLastColumn());
  const data = sheet.getRange(3, 1, lastRow - 2, nbCols).getValues();

  for (let i = 0; i < data.length; i += NB_ROWS_BLOCK) {
    const r1 = data[i] || [], r2 = data[i + 1] || [];
    const hasData = r1.some(v => v !== '' && v != null) || r2.some(v => v !== '' && v != null);
    if (!hasData) continue;

    const row1Abs = 3 + i;
    templateClient
      .getRange(1, col, NB_ROWS_BLOCK, 1)
      .copyTo(sheet.getRange(row1Abs, col, NB_ROWS_BLOCK, 1),
              SpreadsheetApp.CopyPasteType.PASTE_FORMAT, false);
  }
}
function getWeekColsFromProps_(sheet) {
  const props = PropertiesService.getDocumentProperties();
  const key = PROP_WEEK_BORDER_COLS_PREFIX + sheet.getSheetId();
  const prev = (props.getProperty(key) || '')
    .split(',').map(s => parseInt(s, 10)).filter(n => !isNaN(n));
  return prev;
}
function computeWeekColsFromHeaders_(sheet, targetDate) {
  const { plages } = getPlagesCachedForSheet_(sheet);
  if (!plages || !plages.length || !targetDate) return [];
  const d = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
  const cols = [];
  for (let i = 0; i < plages.length; i++) {
    const p = plages[i]; if (!p) continue;
    const s = new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate());
    const e = new Date(p.end.getFullYear(),   p.end.getMonth(),   p.end.getDate());
    if (d >= s && d <= e) cols.push(FIRST_DATA_COL + i);
  }
  return cols;
}
function scrollToHighlightedWeek_(sheet, highlightedCol) {
  if (!sheet || !highlightedCol) return;

  const maxCols = Math.max(1, sheet.getMaxColumns());
  const anchorCol = Math.min(maxCols, Math.max(1, highlightedCol + SHIFT_RIGHT));

  const frozen = Math.max(1, sheet.getFrozenRows() || 0);
  const lastRow = Math.max(frozen + 4, sheet.getLastRow());
  const anchorRow = Math.min(Math.max(frozen + 4, Math.floor((lastRow + frozen) / 2)), lastRow);

  sheet.activate();
  sheet.setActiveSelection(sheet.getRange(anchorRow, anchorCol));
}


function __compressPacks_(packs) {
  // packs: [{r1,c1,c2},...]
  // retour: { [r1]: [[c1,c2], ...], ... }
  const out = {};
  (packs || []).forEach(pk => {
    if (!pk || pk.r1 == null || pk.c1 == null || pk.c2 == null) return;
    const key = String(pk.r1);
    if (!out[key]) out[key] = [];
    out[key].push([pk.c1, pk.c2]);
  });
  // On trie et fusionne les runs par r1 pour compacter encore
  Object.keys(out).forEach(k => {
    const runs = out[k].slice().sort((a,b)=>a[0]-b[0] || a[1]-b[1]);
    const merged = [];
    for (const [a,b] of runs) {
      if (!merged.length || a > merged[merged.length-1][1] + 1) merged.push([a,b]);
      else merged[merged.length-1][1] = Math.max(merged[merged.length-1][1], b);
    }
    out[k] = merged;
  });
  return out;
}

function __decompressPacks_(obj) {
  // obj: { r1: [[c1,c2],...], ... } -> [{r1,c1,c2},...]
  const out = [];
  if (!obj) return out;
  Object.keys(obj).forEach(k => {
    const r1 = parseInt(k, 10);
    (obj[k] || []).forEach(run => {
      const c1 = +run[0], c2 = +run[1];
      if (!isNaN(r1) && !isNaN(c1) && !isNaN(c2)) out.push({ r1, c1, c2 });
    });
  });
  return out;
}


function focusHighlightedWeekAtOpen_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const active = ss.getActiveSheet();
  const names = [SHEET_CLIENTS, SHEET_PONCTUEL];
  const targetSheet = (active && names.includes(active.getName()))
    ? active : (ss.getSheetByName(SHEET_CLIENTS) || ss.getSheetByName(SHEET_PONCTUEL));
  if (!targetSheet) return;

  let cols = computeWeekColsFromHeaders_(targetSheet, todayMidnight_());
  if (!cols || cols.length === 0) cols = getWeekColsFromProps_(targetSheet);
  if (!cols || cols.length === 0) return;

  scrollToHighlightedWeek_(targetSheet, cols[0]);
}

/************
  PRÉVISIONS (orange clair / rouge / rouge très foncé)
  Supporte WEEKLY, BIWEEKLY (/15J) et MONTHLY (/mois)
*************/



// === (2) CLEAR — un seul bloc (optimisé), renvoie la liste de packs restants ===
function clearForecastForBlock_(sheet, row1Abs) {
  const packs = loadForecastPacks_(sheet);
  if (!packs || !packs.length) return [];

  const keep = [];
  const a1s  = [];
  const bg   = blockAlternanceColor_(row1Abs);

  packs.forEach(pk => {
    if (pk.r1 !== row1Abs) { keep.push(pk); return; }
    try {
      a1s.push(
        sheet.getRange(row1Abs, pk.c1, NB_ROWS_BLOCK, pk.c2 - pk.c1 + 1).getA1Notation()
      );
    } catch (_) {}
  });

  if (a1s.length) __applyColorBatches_(sheet, a1s, bg);

  storeForecastPacks_(sheet, keep);
  SpreadsheetApp.flush();
  return keep;
}



function repaintForecastForBlocksOnEdit_(sheet, r1List) {
  if (!isForecastEnabled_()) return;
  if (!r1List || !r1List.length) return;

  const targets = Array.from(new Set(r1List)).filter(n => typeof n === 'number' && n >= FIRST_DATA_ROW);

  const lastRow = sheet.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL || targets.length === 0) return;

  const width  = lastCol - (FIRST_DATA_COL - 1);
  const height = lastRow - (FIRST_DATA_ROW - 1);

  const { plages } = getPlagesCachedForSheet_(sheet);
  const startCol = Math.max(FIRST_DATA_COL, getNextWeekStartCol_(sheet)); // S+1
  const jS1      = startCol - FIRST_DATA_COL;
  const targetPlage = plages[jS1];
  if (!targetPlage) return;

  // 1) Nettoyage ancien S+1 pour ces blocs (inchangé)
  const packsAll = loadForecastPacks_(sheet) || [];
  const keep = [];
  const clearByColor = new Map();
  function qPush(color, r1, c1, c2) {
    const a1 = sheet.getRange(r1, c1, NB_ROWS_BLOCK, c2 - c1 + 1).getA1Notation();
    if (!clearByColor.has(color)) clearByColor.set(color, []);
    clearByColor.get(color).push(a1);
  }
  const targetSet = new Set(targets);
  packsAll.forEach(pk => {
    if (!targetSet.has(pk.r1)) { keep.push(pk); return; }
    qPush(blockAlternanceColor_(pk.r1), pk.r1, pk.c1, pk.c2);
  });
  clearByColor.forEach((a1s, color) => __applyColorBatches_(sheet, a1s, color));

  // 2) Repeinture S+1 — voie rapide si peu de blocs, fallback sinon
  const paintByColor = new Map([
    [FORECAST_BG_NEW,     []],
    [FORECAST_BG_URGENT,  []],
    [FORECAST_BG,         []],
    [FORECAST_BG_OK,      []]
  ]);
  const newPacks = [];

  const fewBlocksThreshold = Math.floor((height / NB_ROWS_BLOCK) * 0.25); // 25% des blocs
  const useFastPath = targets.length <= Math.max(3, fewBlocksThreshold);

  if (useFastPath) {
    // ⚡️ FAST-PATH: lecture strictement localisée aux blocs ciblés
    targets.forEach(r1Abs => {
      if (r1Abs + 1 > lastRow) return;

      const contrat = (sheet.getRange(r1Abs, COL_CONTRAT).getDisplayValue() || '').trim();
      const freq = getFrequenceFromContrat_(contrat);
      if (!freq) return;

      const rowVals = sheet.getRange(r1Abs, FIRST_DATA_COL, NB_ROWS_BLOCK, width).getValues();
      const rowDisp = sheet.getRange(r1Abs, FIRST_DATA_COL, NB_ROWS_BLOCK, width).getDisplayValues();
      const row1Vals = rowVals[0], row1Disp = rowDisp[0], row2Disp = rowDisp[1];

      // S+1 déjà rempli → pas de surbrillance
      if ((String(row1Disp[jS1] || '').trim() !== '') || (String(row2Disp[jS1] || '').trim() !== '')) return;

      const infoLast = getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
      const lastDate = infoLast ? infoLast.date : null;

      if (!lastDate) {
        if (hasPlanifFromIndex_(row1Disp, row2Disp, jS1)) return;
        paintByColor.get(FORECAST_BG_NEW).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
        newPacks.push({ r1: r1Abs, c1: startCol, c2: startCol });
        return;
      }

      let dueDate = null;
      if      (freq === 'WEEKLY')   dueDate = addDays_(lastDate, 7);
      else if (freq === 'BIWEEKLY') dueDate = addDays_(lastDate, 14);
      else if (freq === 'MONTHLY')  dueDate = addMonths_(lastDate, 1);
      if (!dueDate || dueDate > targetPlage.end) return;

      let weeksBehind = 0;
      const dueIdx = findColumnIndexForDate_(plages, dueDate);
      if (dueIdx >= 0) weeksBehind = Math.max(0, jS1 - dueIdx);
      else {
        const ms = 24*60*60*1000;
        weeksBehind = Math.max(0, Math.floor((targetPlage.start - dueDate) / ms / 7));
      }

      const color = (weeksBehind >= 2) ? FORECAST_BG_URGENT : (weeksBehind === 1 ? FORECAST_BG : FORECAST_BG_OK);
      paintByColor.get(color).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
      newPacks.push({ r1: r1Abs, c1: startCol, c2: startCol });
    });
  } else {
    // 🔁 Fallback: chemin original (lecture globale puis boucle) — inchangé
    const ABdisp     = sheet.getRange(FIRST_DATA_ROW, 1,            height, 2     ).getDisplayValues();
    const rowValsAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getValues();
    const rowDispAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getDisplayValues();

    targets.forEach(r1Abs => {
      const r1rel = r1Abs - FIRST_DATA_ROW;
      const r2rel = r1rel + 1; if (r2rel >= height) return;

      const contrat = (ABdisp[r1rel][COL_CONTRAT - 1] || '').trim();
      const freq = getFrequenceFromContrat_(contrat);
      if (!freq) return;

      const row1Vals = rowValsAll[r1rel];
      const row1Disp = rowDispAll[r1rel];
      const row2Disp = rowDispAll[r2rel];

      const filledS1 = (String(row1Disp[jS1] || '').trim() !== '' || String(row2Disp[jS1] || '').trim() !== '');
      if (filledS1) return;

      const infoLast = getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
      const lastDate = infoLast ? infoLast.date : null;

      if (!lastDate) {
        const hasFuturePlanif = hasPlanifFromIndex_(row1Disp, row2Disp, jS1);
        if (hasFuturePlanif) return;
        paintByColor.get(FORECAST_BG_NEW).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
        newPacks.push({ r1: r1Abs, c1: startCol, c2: startCol });
        return;
      }

      let dueDate = null;
      if      (freq === 'WEEKLY')   dueDate = addDays_(lastDate, 7);
      else if (freq === 'BIWEEKLY') dueDate = addDays_(lastDate, 14);
      else if (freq === 'MONTHLY')  dueDate = addMonths_(lastDate, 1);
      if (!dueDate || dueDate > targetPlage.end) return;

      let weeksBehind = 0;
      const dueIdx = findColumnIndexForDate_(plages, dueDate);
      if (dueIdx >= 0) weeksBehind = Math.max(0, jS1 - dueIdx);
      else {
        const ms = 24*60*60*1000;
        weeksBehind = Math.max(0, Math.floor((targetPlage.start - dueDate) / ms / 7));
      }
      const color = (weeksBehind >= 2) ? FORECAST_BG_URGENT : (weeksBehind === 1 ? FORECAST_BG : FORECAST_BG_OK);
      paintByColor.get(color).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
      newPacks.push({ r1: r1Abs, c1: startCol, c2: startCol });
    });
  }

  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_NEW),     FORECAST_BG_NEW);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_URGENT),  FORECAST_BG_URGENT);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG),         FORECAST_BG);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_OK),      FORECAST_BG_OK);

  storeForecastPacks_(sheet, keep.concat(newPacks));
  SpreadsheetApp.flush();


}










// Détecte si l'édition a vidé des cellules et, le cas échéant, repeint les blocs touchés
function maybeRepaintForecastOnClear_(e) {
  if (!isForecastEnabled_()) return;
  const sh = e && e.range && e.range.getSheet();
  if (!sh) return;
  const name = sh.getName();
  if (name !== SHEET_CLIENTS && name !== SHEET_PONCTUEL) return;

  const rng = e.range;
  const r0 = rng.getRow(), c0 = rng.getColumn();
  const h  = rng.getNumRows(), w = rng.getNumColumns();

  // Limite à la zone données (C3→)
  const lastRow = sh.getLastRow();
  const rStart  = Math.max(FIRST_DATA_ROW, r0);
  const cStart  = Math.max(FIRST_DATA_COL, c0);
  const rEnd    = Math.min(lastRow, r0 + h - 1);
  const cEnd    = c0 + w - 1;
  if (rEnd < FIRST_DATA_ROW || cEnd < FIRST_DATA_COL) return;

  const disp = sh.getRange(rStart, cStart, rEnd - rStart + 1, cEnd - cStart + 1).getDisplayValues();

  // Repère les blocs (r1Abs) où au moins 1 cellule de la sélection est désormais VIDE
  const blocksToRepaint = new Set();
  for (let dr = 0; dr < disp.length; dr++) {
    for (let dc = 0; dc < disp[dr].length; dc++) {
      const now = String(disp[dr][dc] || '').trim();
      if (now !== '') continue; // on ne s'intéresse qu'aux cellules vidées
      const rAbs = rStart + dr;
      const r1 = ((rAbs - FIRST_DATA_ROW) % NB_ROWS_BLOCK === 0) ? rAbs : (rAbs - 1);
      blocksToRepaint.add(r1);
    }
  }
  if (!blocksToRepaint.size) return;

  // ➜ NOUVEAU : repeint tous les blocs touchés d'un coup (beaucoup plus rapide)
  repaintForecastForBlocksOnEdit_(sh, Array.from(blocksToRepaint));
}

function maybeClearForecastColorOnEdit_(e) {
  if (!isForecastEnabled_()) return;

  const sh = e && e.range && e.range.getSheet();
  if (!sh) return;
  const name = sh.getName();
  if (name !== SHEET_CLIENTS && name !== SHEET_PONCTUEL) return;

  const rng   = e.range;
  const r0    = rng.getRow(), c0 = rng.getColumn();
  const h     = rng.getNumRows(), w = rng.getNumColumns();

  const lastRow = sh.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sh.getLastColumn());
  const rStart  = Math.max(FIRST_DATA_ROW, r0);
  const cStart  = Math.max(FIRST_DATA_COL, c0);
  const rEnd    = Math.min(lastRow, r0 + h - 1);
  const cEnd    = Math.min(lastCol, c0 + w - 1);
  if (rEnd < FIRST_DATA_ROW || cEnd < FIRST_DATA_COL) return;

  // Lecture de la zone éditée
  const disp = sh.getRange(rStart, cStart, rEnd - rStart + 1, cEnd - cStart + 1).getDisplayValues();

  // Colonnes de la semaine courante (à préserver en BLEU)
  const currSet = new Set(getCurrentWeekCols_(sh));

  // 1) Colonnes désormais RENSEIGNÉES, groupées par bloc (r1Abs)
  const colsToClearByBlock = new Map(); // r1Abs -> Set(cols)
  const minEditedColByBlock = new Map();

  for (let dr = 0; dr < disp.length; dr++) {
    for (let dc = 0; dc < disp[dr].length; dc++) {
      const now = String(disp[dr][dc] || '').trim();
      if (!now) continue; // on ne s'intéresse qu'aux cellules RENSEIGNÉES

      const rAbs = rStart + dr;
      const cAbs = cStart + dc;
      const r1   = ((rAbs - FIRST_DATA_ROW) % NB_ROWS_BLOCK === 0) ? rAbs : (rAbs - 1);

      if (!colsToClearByBlock.has(r1)) colsToClearByBlock.set(r1, new Set());
      colsToClearByBlock.get(r1).add(cAbs);

      const prev = minEditedColByBlock.get(r1);
      if (prev == null || cAbs < prev) minEditedColByBlock.set(r1, cAbs);
    }
  }
  if (colsToClearByBlock.size === 0) return;

  // 2) Packs + A1 à repeindre
  let packs = loadForecastPacks_(sh) || [];
  const clearA1ByColor = new Map(); // color -> A1[]

  function pushClearA1_(color, r1, c1, c2) {
    if (c2 < c1) return;
    const a1 = sh.getRange(r1, c1, NB_ROWS_BLOCK, c2 - c1 + 1).getA1Notation();
    if (!clearA1ByColor.has(color)) clearA1ByColor.set(color, []);
    clearA1ByColor.get(color).push(a1);
  }

  colsToClearByBlock.forEach((colSet, r1) => {
    const baseColor = blockAlternanceColor_(r1);

    // Sépare les colonnes éditées : semaine courante vs le reste
    const colsAll = Array.from(colSet).sort((a,b)=>a-b);
    const colsCW  = colsAll.filter(c => currSet.has(c));
    const colsOut = colsAll.filter(c => !currSet.has(c));

    // a) Hors semaine courante → on remet la couleur d’alternance (on efface les prévisions)
    toRuns_(colsOut).forEach(([a, b]) => {
      pushClearA1_(baseColor, r1, a, b);
      __subtractIntervalFromPacksForBlock_(packs, r1, a, b);
    });

    // b) Semaine courante → on GARDE le BLEU
    toRuns_(colsCW).forEach(([a, b]) => {
      pushClearA1_(HIGHLIGHT_COLUMN_BG, r1, a, b);
      __subtractIntervalFromPacksForBlock_(packs, r1, a, b); // sans effet en pratique ici, mais safe
    });

    // c) Purge des packs strictement avant la 1re col éditée
    const cEdited = minEditedColByBlock.get(r1);
    if (cEdited != null) {
      for (let i = packs.length - 1; i >= 0; i--) {
        const pk = packs[i];
        if (pk.r1 !== r1) continue;
        if (pk.c2 < cEdited) { pushClearA1_(baseColor, r1, pk.c1, pk.c2); packs.splice(i, 1); continue; }
        if (pk.c1 < cEdited && cEdited <= pk.c2) {
          pushClearA1_(baseColor, r1, pk.c1, cEdited - 1);
          pk.c1 = cEdited;
        }
      }
    }
  });

  // 3) Application groupée
  clearA1ByColor.forEach((a1s, color) => __applyColorBatches_(sh, a1s, color));

  storeForecastPacks_(sh, packs);
  SpreadsheetApp.flush();
}







// Menu
function activerPrevisionsMenu_() {
  PropertiesService.getDocumentProperties().setProperty(PROP_FORECAST_ENABLED, '1');
  appliquerPrevisionsToutesFeuilles_();
  SpreadsheetApp.getActive().toast('Prévisions activées 🔮 (Semaine +1 uniquement)', 'Gestion client', 3);

  SpreadsheetApp.getUi().alert(
    'Prévisions activées (S+1 uniquement)',
    'Les surbrillances ne concernent QUE la Semaine +1 (la semaine à venir).\n\n' +
    'Légende des couleurs (pour la case S+1) :\n' +
    '• Nouveau client : BLEU\n' +
    '• Dans le délai : ORANGE CLAIR\n' +
    '• Retard 1 semaine : ROUGE\n' +
    '• Retard ≥ 2 semaines : ROUGE TRÈS FONCÉ\n\n' +
    'Seules les interventions VALIDÉES (Terminé/Planifié/Transports) sont prises en compte pour le retard.\n' +
    'Les statuts "Annulé" ou "Météo" ne comptent pas.',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
}






function desactiverPrevisionsMenu_() {
  PropertiesService.getDocumentProperties().setProperty(PROP_FORECAST_ENABLED, '0');
  clearPrevisionsToutesFeuilles_();
  SpreadsheetApp.getActive().toast('Prévisions désactivées 🧹', 'Gestion client', 3);
}



function isForecastEnabled_() {
  return PropertiesService.getDocumentProperties().getProperty(PROP_FORECAST_ENABLED) === '1';
}

// Appliquer / nettoyer sur toutes feuilles
// ⚡️ MICRO-PATCH: n'appelle plus mettreEnValeurColonneJourSurFeuille_ ici
function appliquerPrevisionsToutesFeuilles_() {
  if (!isForecastEnabled_()) return;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(n => {
    const sh = ss.getSheetByName(n);
    if (!sh) return;
    // on ne re-surligne pas la semaine ici : inutile et coûteux
    clearPrevisionsSurFeuille_(sh);
    appliquerPrevisionsSurFeuille_(sh);
  });
}

// ⚡️ MICRO-PATCH: ne relance plus resurlignerApresMaj_ après clear
function clearPrevisionsToutesFeuilles_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(n => {
    const sh = ss.getSheetByName(n);
    if (sh) clearPrevisionsSurFeuille_(sh);
  });
}





// Helpers prévisions
function normalize_(s) {
  return ('' + (s || ''))
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // enlève les accents
    .replace(/[\u00A0\u202F]/g, ' ')                  // NBSP → espace normal
    .replace(/\s+/g, ' ')
    .trim();
}

// Y a-t-il au moins un "Planifié 📆" à partir de l’index donné (inclus) ?
function hasPlanifFromIndex_(row1Disp, row2Disp, startIndex) {
  const len = Math.max(row1Disp.length, row2Disp.length);
  const j0 = Math.max(0, (startIndex|0));
  for (let j = j0; j < len; j++) {
    if (isPlanifieMark_(row1Disp[j]) || isPlanifieMark_(row2Disp[j])) return true;
  }
  return false;
}


// Détermine la fréquence à partir du libellé contrat
function getFrequenceFromContrat_(contrat) {
  const t  = normalize_(contrat || '').replace(/\b\d+\s*h\b/g, '').trim();
  const tn = t.replace(/\s+/g, '');

  // Hebdomadaire
  if (/\b(hebdo|hebdomadaire|semaine|sem|7\s*j(?:ours)?)\b/.test(t) ||
      /\/(?:semaine|sem|7j(?:ours)?)\b/.test(tn)) {
    return 'WEEKLY';
  }

  // 15 jours / quinzaine
  if (
    /\b(quinzaine|bi[-\s]?hebdo(?:madaire)?|2\s*sem(?:aines)?)\b/.test(t) ||
    /\/15j\b/.test(tn) ||
    /\b15\s*\/\s*j\b/.test(t) ||
    /\b15\s*j(?:ours)?\b/.test(t) ||
    /\b15j\b/.test(tn)
  ) {
    return 'BIWEEKLY';
  }

  // Mensuel
  if (/\b(mensuel(?:le)?|30\s*j(?:ours)?)\b/.test(t) ||
      /\/mois\b/.test(tn)) {
    return 'MONTHLY';
  }

  return null;
}


// Rang d’ordre pour le tri interne aux groupes (contrat)
function contratOrderRank_(contrat) {
  const f = getFrequenceFromContrat_(contrat || '');
  if (f === 'WEEKLY')   return 0; // / Semaine
  if (f === 'BIWEEKLY') return 1; // / 15J
  if (f === 'MONTHLY')  return 2; // / Mois
  return 3;                         // tout le reste (après)
}

// --- Mapping lisible pour la priorité d'appel ---
function forecastPriorityInfo_(firstColor) {
  if (firstColor === FORECAST_BG_NEW) {
    return { prio: 4, label: 'Extrême', statutLabel: 'Nouveau client (aucune intervention passée)' };
  }
  if (firstColor === FORECAST_BG_URGENT) {
    return { prio: 3, label: 'Élevé', statutLabel: 'Très urgent (≥ 2 sem. de retard)' };
  }
  if (firstColor === FORECAST_BG) {
    return { prio: 2, label: 'Moyenne', statutLabel: 'Retard 1 semaine' };
  }
  return { prio: 1, label: 'Faible', statutLabel: 'Dans le délai' };
}

// ✅/❌ marquages
// ❌ “Annulé/Météo” => non effectué  (⚠️ Planifié n'est plus invalidant)
function containsAnnuleMeteoPlanifie_(txt) { // nom conservé pour compatibilité
  if (!txt) return false;
  const raw = String(txt);
  const t = normalize_(raw);
  return (raw.includes('❌') || raw.includes('⛈️') || t.includes('annule') || t.includes('meteo'));
}
// ✅ “Planifié 📆” => considéré comme effectué
function isPlanifieMark_(txt) {
  if (!txt) return false;
  const raw = String(txt);
  const t = normalize_(raw);
  return raw.includes('📆') || t.includes('planifie');
}




// ✅ “Terminé” (ou icône) OU “X Transport(s) 🚛” OU “Planifié 📆” => effectué
// ✅ "Terminé" (ou icône) OU "X Transport(s) 🚛" => effectué
// ❌ "Annulé ❌" / "Météo ⛈️" => non effectué
// ✅ “Terminé”/icône OU “X Transport(s) 🚛” OU “Planifié 📆” => effectué
// ❌ “Annulé ❌” / “Météo ⛈️” => non effectué
function isEffectiveMark_(t1, t2) {
  const s1 = String(t1 || '').trim();
  const s2 = String(t2 || '').trim();

  // ❌ Annulé / Météo = non effectué
  if (containsAnnuleMeteoPlanifie_(s1) || containsAnnuleMeteoPlanifie_(s2)) return false;

  // ✅ "X Transport(s) 🚛"
  if (extractTransportCount_(s1) > 0 || extractTransportCount_(s2) > 0) return true;

  // ✅ icônes de validation
  if (s1.includes('✔') || s2.includes('✔') || s1.includes('✅') || s2.includes('✅')) return true;

  // ✅ "Terminé"/"Terminée"/"Terminer"
  const both = normalize_(s1 + ' ' + s2);
  if (/\btermin(?:e|ee|er)\b/.test(both)) return true;

  // ✅ "Planifié" (emoji ou texte)
  if (isPlanifieMark_(s1) || isPlanifieMark_(s2)) return true;

  return false;
}







// dernière intervention : renvoie {col, date} ou null
// dernière intervention : renvoie {col, date} ou null
function getLastInterventionForBlock_(sheet, row1Abs, lastCol) {
  const width = lastCol - 2; if (width <= 0) return null;

  const row1Vals = sheet.getRange(row1Abs, 3, 1, width).getValues()[0];           // dates (ligne 1)
  const row1Disp = sheet.getRange(row1Abs, 3, 1, width).getDisplayValues()[0];    // textes (ligne 1)
  const row2Disp = sheet.getRange(row1Abs + 1, 3, 1, width).getDisplayValues()[0];// textes (ligne 2)
  const { plages } = getPlagesCachedForSheet_(sheet);

  let best = null;
  for (let c = 3; c <= lastCol; c++) {
    const i  = c - 3;
    const dv = row1Vals[i];
    const dt = (dv && Object.prototype.toString.call(dv) === '[object Date]' && !isNaN(dv.getTime())) ? dv : null;
    const effective = isEffectiveMark_(row1Disp[i], row2Disp[i]);
    if (dt && effective) {
      if (!best || dt > best.date) best = { col: c, date: dt };
    }
  }

  // Fallback : "Terminé"/"Planifié" dans la SEMAINE COURANTE → date = début de semaine
  if (!best) {
    const today   = todayMidnight_();
    const currIdx = findColumnIndexForDate_(plages, today);
    if (currIdx >= 0) {
      const s1 = String(row1Disp[currIdx] || '');
      const s2 = String(row2Disp[currIdx] || '');
      const norm = normalize_(s1 + ' ' + s2);

      const hasTermine =
        s1.includes('✔') || s2.includes('✔') ||
        s1.includes('✅') || s2.includes('✅') ||
        /\btermin(?:e|ee|er)\b/.test(norm);
      const hasPlanifie = isPlanifieMark_(s1) || isPlanifieMark_(s2);

      if (hasTermine || hasPlanifie) {
        const p = plages[currIdx];
        if (p && p.start) {
          best = {
            col: FIRST_DATA_COL + currIdx,
            date: new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate())
          };
        }
      }
    }
  }
  return best;
}




// Parcourt de droite à gauche les colonnes visibles : renvoie { col, date } ou null
function getLastInterventionFromArrays_(row1Vals, row1Disp, row2Disp) {
  for (let i = row1Vals.length - 1; i >= 0; i--) {
    const dv = row1Vals[i];
    const isDate = (dv && Object.prototype.toString.call(dv) === '[object Date]' && !isNaN(dv.getTime()));
    if (!isDate) continue;
    if (isEffectiveMark_(row1Disp[i], row2Disp[i])) {
      return { col: i + FIRST_DATA_COL, date: dv };
    }
  }
  return null;
}

/** Idem mais avec un léger filet de sécurité :
 * si rien n’est trouvé et que la SEMAINE COURANTE contient "Terminé" (pas "Planifié"),
 * on fabrique une date = début de la semaine courante pour l’index concerné.
 */
/** Cherche la dernière intervention EFFECTUÉE ≤ fin de la semaine courante.
 *  Fallback : si la SEMAINE COURANTE contient Terminé/Planifié, on fabrique une date au début de cette semaine.
 */
function getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp) {
  // 1) D'abord : dernière intervention EFFECTUÉE ≤ fin semaine courante
  const info = getLastInterventionUpToCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
  if (info) return info;

  // 2) Filet de sécurité : "Terminé" OU "Planifié" dans la SEMAINE COURANTE
  const today   = todayMidnight_();
  const currIdx = findColumnIndexForDate_(plages, today);
  if (currIdx < 0) return null;

  const s1 = String(row1Disp[currIdx] || '');
  const s2 = String(row2Disp[currIdx] || '');
  const norm = normalize_(s1 + ' ' + s2);

  const hasTermine =
    s1.includes('✔') || s2.includes('✔') ||
    s1.includes('✅') || s2.includes('✅') ||
    /\btermin(?:e|ee|er)\b/.test(norm);

  const hasPlanifie = (isPlanifieMark_(s1) || isPlanifieMark_(s2));

  if (hasTermine || hasPlanifie) {
    const p = plages[currIdx];
    if (p && p.start) {
      return {
        col: FIRST_DATA_COL + currIdx,
        date: new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate())
      };
    }
  }
  return null;
}







// regroupe colonnes contiguës
function toRuns_(cols) {
  const a = Array.from(new Set(cols)).sort((x, y) => x - y);
  if (a.length === 0) return [];
  const runs = [];
  let s = a[0], p = a[0];
  for (let i = 1; i < a.length; i++) {
    if (a[i] === p + 1) { p = a[i]; continue; }
    runs.push([s, p]); s = p = a[i];
  }
  runs.push([s, p]);
  return runs;
}
// 1re colonne de la semaine SUIVANTE
function getNextWeekStartCol_(sheet) {
  const today = todayMidnight_();

  const curCols = computeWeekColsFromHeaders_(sheet, today);
  if (curCols && curCols.length) return Math.max.apply(null, curCols) + 1;

  const next = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 7);
  const nextCols = computeWeekColsFromHeaders_(sheet, next);
  if (nextCols && nextCols.length) return Math.min.apply(null, nextCols);

  return 3;
}
// mémorisation/effacement des zones colorées
function storeForecastPacks_(sheet, packs) {
  const key = PROP_FORECAST_PACKS_PREFIX + sheet.getSheetId();
  try {
    const compact = __compressPacks_(packs || []);
    const json = JSON.stringify(compact);
    // Si trop gros, JSON.stringify lancera rarement une erreur,
    // mais surtout setProperty peut échouer silencieusement → on try/catch.
    PropertiesService.getDocumentProperties().setProperty(key, json);
  } catch (e) {
    // En cas d’échec, on efface l’état et on laisse la feuille "peinte".
    // À la prochaine action "clear/appliquer", tout sera recalculé proprement.
    try { PropertiesService.getDocumentProperties().deleteProperty(key); } catch(_) {}
    Logger.log('storeForecastPacks_ failed, packs dropped: ' + (e && e.message));
  }
}

function loadForecastPacks_(sheet) {
  const key = PROP_FORECAST_PACKS_PREFIX + sheet.getSheetId();
  try {
    const js = PropertiesService.getDocumentProperties().getProperty(key);
    if (!js) return [];
    const obj = JSON.parse(js);
    return __decompressPacks_(obj);
  } catch(e) {
    Logger.log('loadForecastPacks_ failed -> returning [] : ' + (e && e.message));
    return [];
  }
}

function clearForecastPacks_(sheet) {
  const key = PROP_FORECAST_PACKS_PREFIX + sheet.getSheetId();
  PropertiesService.getDocumentProperties().deleteProperty(key);
}



// === (1) CLEAR — toute la feuille (optimisé RangeList) ===

function clearPrevisionsSurFeuille_(sheet) {
  const packs = loadForecastPacks_(sheet);
  if (!packs || packs.length === 0) return;

  // Agrège les plages à réinitialiser par couleur d'alternance du bloc
  const byColor = new Map(); // color -> A1[]
  function push(color, a1) {
    if (!byColor.has(color)) byColor.set(color, []);
    byColor.get(color).push(a1);
  }

  packs.forEach(pk => {
    try {
      const bg = blockAlternanceColor_(pk.r1); // gris / blanc selon l’index du bloc
      const a1 = sheet
        .getRange(pk.r1, pk.c1, NB_ROWS_BLOCK, pk.c2 - pk.c1 + 1)
        .getA1Notation();
      push(bg, a1);
    } catch (_) {}
  });

  // Applique en gros lots (beaucoup moins d’appels que boucle par pack)
  byColor.forEach((a1s, color) => __applyColorBatches_(sheet, a1s, color));

  // Vide l’état mémorisé
  clearForecastPacks_(sheet);
  SpreadsheetApp.flush();
}

// === Helpers dates ===
function addDays_(d, n) {
  const dt = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  dt.setDate(dt.getDate() + n);
  return dt;
}
function addMonths_(d, m) {
  const y = d.getFullYear(), M = d.getMonth(), day = d.getDate();
  const target = new Date(y, M + m, 1);
  const lastDay = new Date(target.getFullYear(), target.getMonth() + 1, 0).getDate();
  target.setDate(Math.min(day, lastDay));
  return target;
}
function findColumnIndexForDate_(plages, date) {
  if (!date) return -1;
  const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  for (let i = 0; i < plages.length; i++) {
    const p = plages[i]; if (!p) continue;
    const s = new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate());
    const e = new Date(p.end.getFullYear(),   p.end.getMonth(),   p.end.getDate());
    if (d >= s && d <= e) return i;
  }
  return -1;
}

// Dernière intervention EFFECTUÉE (Terminé/Planifié/Transports) ≤ fin de la SEMAINE COURANTE
function getLastInterventionUpToCurrentWeek_(plages, row1Vals, row1Disp, row2Disp) {
  const today   = todayMidnight_();
  const currIdx = findColumnIndexForDate_(plages, today);
  const maxDate = (currIdx >= 0 && plages[currIdx]) ? plages[currIdx].end : today;

  for (let i = row1Vals.length - 1; i >= 0; i--) {
    const dv = row1Vals[i];
    const isDate = (dv && Object.prototype.toString.call(dv) === '[object Date]' && !isNaN(dv.getTime()));
    if (!isDate) continue;
    if (dv > maxDate) continue; // ⛔ on ignore tout ce qui est dans le futur
    if (isEffectiveMark_(row1Disp[i], row2Disp[i])) {
      return { col: i + FIRST_DATA_COL, date: dv };
    }
  }
  return null;
}



// Helper: retranche un intervalle [a,b] (colonnes absolues) aux packs d’un bloc r1
function __subtractIntervalFromPacksForBlock_(packs, r1, a, b) {
  for (let i = packs.length - 1; i >= 0; i--) {
    const pk = packs[i];
    if (pk.r1 !== r1) continue;
    if (pk.c2 < a || pk.c1 > b) continue; // disjoint

    // Le pack est entièrement couvert par [a,b] -> suppression
    if (a <= pk.c1 && pk.c2 <= b) {
      packs.splice(i, 1);
      continue;
    }
    // L’intervalle coupe le pack au milieu -> on scinde en 2
    if (pk.c1 < a && b < pk.c2) {
      const left  = { r1: pk.r1, c1: pk.c1, c2: a - 1 };
      const right = { r1: pk.r1, c1: b + 1, c2: pk.c2   };
      packs.splice(i, 1);
      packs.push(left, right);
      continue;
    }
    // Coupe bord droit
    if (pk.c1 < a && pk.c2 <= b) {
      pk.c2 = a - 1;
      continue;
    }
    // Coupe bord gauche
    if (a <= pk.c1 && b < pk.c2) {
      pk.c1 = b + 1;
      continue;
    }
  }
}



let __PLANIFIE_CANON = null;
function getCanonPlanifieText_() {
  if (__PLANIFIE_CANON) return __PLANIFIE_CANON;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const tpl = ss.getSheetByName(SHEET_TEMPLATE_CLIENT);
  __PLANIFIE_CANON = 'Planifié 📆'; // valeur de secours

  if (tpl) {
    const lastCol = Math.min(NB_COLS_BLOCK, tpl.getLastColumn());
    const width = Math.max(0, lastCol - (FIRST_DATA_COL - 1));
    const canon = __buildCanonStatutsFromTemplate_(tpl, width);
    if (canon && canon.items && canon.items.length) {
      const found = canon.items.find(v => /planifi/i.test(String(v)) || String(v).includes('📆'));
      if (found) __PLANIFIE_CANON = String(found);
    }
  }
  return __PLANIFIE_CANON;
}


// Helper: applique une couleur à beaucoup de plages en lots pour éviter les limites internes
function __applyColorBatches_(sheet, a1s, color) {
  if (!a1s || !a1s.length) return;
  const CHUNK = 200; // taille raisonnable ; ajuste si besoin
  for (let i = 0; i < a1s.length; i += CHUNK) {
    const slice = a1s.slice(i, i + CHUNK);
    sheet.getRangeList(slice).setBackground(color);
  }
}

/**
 * Version optimisée (très peu d'appels Apps Script)
 * - Lecture batch des données (toutes les lignes/colonnes en une fois)
 * - Calcul des colonnes à peindre pour chaque bloc (logique identique)
 * - Application des couleurs par "RangeList" groupées par couleur
 * - Packs toujours stockés en fin (même structure {r1,c1,c2})
 */
/**
 * Applique les prévisions S+1 (uniquement) sur une feuille.
 * Couleur S+1 = retard mesuré à S+1 vs dernière intervention VALIDÉE (Terminé/Transports).
 * WEEKLY: +7j ; BIWEEKLY (/15J): +14j ; MONTHLY (/Mois): +1 mois.
 */
function appliquerPrevisionsSurFeuille_(sheet) {
  const lastRow = sheet.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return 0;

  const width  = lastCol - (FIRST_DATA_COL - 1);
  const height = lastRow - (FIRST_DATA_ROW - 1);

  const { plages } = getPlagesCachedForSheet_(sheet);
  const startCol = Math.max(FIRST_DATA_COL, getNextWeekStartCol_(sheet)); // S+1
  const jS1      = startCol - FIRST_DATA_COL;
  const targetPlage = plages[jS1];
  if (!targetPlage) return 0;

  const ABdisp     = sheet.getRange(FIRST_DATA_ROW, 1,           height, 2     ).getDisplayValues();
  const rowValsAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getValues();
  const rowDispAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getDisplayValues();

  const paintByColor = new Map([
    [FORECAST_BG_NEW,     []],
    [FORECAST_BG_URGENT,  []],
    [FORECAST_BG,         []],
    [FORECAST_BG_OK,      []]
  ]);
  const packs = [];

  for (let r1rel = 0; r1rel < height; r1rel += NB_ROWS_BLOCK) {
    const r2rel = r1rel + 1; if (r2rel >= height) break;
    const r1Abs = FIRST_DATA_ROW + r1rel;

    const contrat = (ABdisp[r1rel][COL_CONTRAT - 1] || '').trim();
    const freq = getFrequenceFromContrat_(contrat);
    if (!freq) continue;

    const row1Vals = rowValsAll[r1rel];
    const row1Disp = rowDispAll[r1rel];
    const row2Disp = rowDispAll[r2rel];

    // S+1 déjà rempli → pas de surbrillance
    const filledS1 = (String(row1Disp[jS1] || '').trim() !== '' || String(row2Disp[jS1] || '').trim() !== '');
    if (filledS1) continue;

    const infoLast = getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
    const lastDate = infoLast ? infoLast.date : null;

    // Cas NOUVEAU CLIENT : BLEU si aucune planif à partir de S+1
    if (!lastDate) {
      const hasFuturePlanif = hasPlanifFromIndex_(row1Disp, row2Disp, jS1);
      if (hasFuturePlanif) continue; // déjà programmé ensuite → ne pas peindre
      paintByColor.get(FORECAST_BG_NEW).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
      packs.push({ r1: r1Abs, c1: startCol, c2: startCol });
      continue;
    }

    // Autres cas : peindre seulement si renouvellement atteint dans S+1
    let dueDate = null;
    if      (freq === 'WEEKLY')   dueDate = addDays_(lastDate, 7);
    else if (freq === 'BIWEEKLY') dueDate = addDays_(lastDate, 14);
    else if (freq === 'MONTHLY')  dueDate = addMonths_(lastDate, 1);
    if (!dueDate || dueDate > targetPlage.end) continue;

    let color;
    let weeksBehind = 0;
    const dueIdx = findColumnIndexForDate_(plages, dueDate);
    if (dueIdx >= 0) {
      weeksBehind = Math.max(0, jS1 - dueIdx);
    } else {
      const ms = 24*60*60*1000;
      weeksBehind = Math.max(0, Math.floor((targetPlage.start - dueDate) / ms / 7));
    }
    if (weeksBehind >= 2)      color = FORECAST_BG_URGENT;
    else if (weeksBehind === 1) color = FORECAST_BG;
    else                        color = FORECAST_BG_OK;

    paintByColor.get(color).push(sheet.getRange(r1Abs, startCol, NB_ROWS_BLOCK, 1).getA1Notation());
    packs.push({ r1: r1Abs, c1: startCol, c2: startCol });
  }

  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_NEW),     FORECAST_BG_NEW);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_URGENT),  FORECAST_BG_URGENT);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG),         FORECAST_BG);
  __applyColorBatches_(sheet, paintByColor.get(FORECAST_BG_OK),      FORECAST_BG_OK);

  storeForecastPacks_(sheet, packs);
  SpreadsheetApp.flush();
  return 0;
}












/************
  Mois FR (utile côté HTML si besoin)
*************/
function moisFr_(m1to12) {
  const arr = ['Janvier','Février','Mars','Avril','Mai','Juin','Juillet','Août','Septembre','Octobre','Novembre','Décembre'];
  return arr[m1to12 - 1] || String(m1to12);
}

/************
  Désactivation silencieuse au démarrage/refresh
*************/
function desactiverPrevisionsSilencieuxAuDemarrage_() {
  const props = PropertiesService.getDocumentProperties();
  if (props.getProperty(PROP_FORECAST_ENABLED) === '1') {
    props.setProperty(PROP_FORECAST_ENABLED, '0');
    try { clearPrevisionsToutesFeuilles_(); } catch (e) { Logger.log(e); }
  }
}

/************
  LISTING PRÉVISIONS – Génération (version améliorée)
*************/

/** Produit la feuille “Listing Prévisions 📞” priorisée (semaine à venir). */


/** Produit la feuille “Listing Prévisions 📞” (6 colonnes, sans colonne « Priorité », avec « Non prioritaire »). */
function genererListingTelephoniquePrevisions() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const listingName = 'Listing Prévisions 📞';
  let sh = ss.getSheetByName(listingName);
  if (!sh) sh = ss.insertSheet(listingName);

  // Réinit + forcer à 6 colonnes (A:F)
  sh.clearContents().clearFormats();
  const totalCols = 6;
  const maxCols = sh.getMaxColumns();
  if (maxCols > totalCols) sh.deleteColumns(totalCols + 1, maxCols - totalCols);

  // En-têtes (Priorité supprimée, Téléphone ↔ Contrat permutés)
  const header = ['Statut', 'Nom', 'Prénom', 'Contrat', '📞 Téléphone', '📅 Dernière intervention'];
  sh.getRange(1, 1, 1, header.length).setValues([header]).setFontWeight('bold');
  sh.setFrozenRows(1);

  const fmt      = fmtJourMoisLong_;
  const fmtShort = fmtJourMoisCourt_;

  // Données (toutes les feuilles client sont consolidées en amont)
  const data = getListingPrevisionsData_();

  let row = 2;
  // On conserve tous les groupes, y compris « Non prioritaire »
  const ORDER = [
    ['Extrême',        FORECAST_BG_NEW],
    ['Élevé',          FORECAST_BG_URGENT],
    ['Moyenne',        FORECAST_BG],
    ['Faible',         FORECAST_BG_OK],
    ['Non prioritaire','#E5E7EB']
  ];

  const groupMeta = [];
  ORDER.forEach(([name, color]) => {
    const arr = data.groups[name] || [];
    if (!arr.length) return;

    // Ligne de section fusionnée A:F (6 colonnes)
    sh.getRange(row, 1, 1, header.length)
      .setValues([[`PRIORITÉ ${name.toUpperCase()} — ${arr.length} client(s)`, '', '', '', '', '']]);
    groupMeta.push({ headerRow: row, color, name, count: arr.length });
    row++;

    // Lignes du groupe (Téléphone ↔ Contrat permutés)
    const block = arr.map(r => {
      let statut = r.statutLabel;
      if (r.planifieFutur && r.nextPlanifDate) {
        statut += ' — Planifié le ' + fmtShort(r.nextPlanifDate);
      } else if (r.planifieFutur) {
        statut += ' — Planifié';
      }
      return [statut, r.nom, r.prenom, r.contrat, r.tel, fmt(r.lastDate)];
    });
    sh.getRange(row, 1, block.length, header.length).setValues(block);
    row += block.length;
  });

  if (row === 2) {
    safeAlert_('Aucun client à afficher pour la semaine à venir.');
    return;
  }

  // Style 6 colonnes
  styliserListingPrevisions_(sh, header.length, groupMeta);
  SpreadsheetApp.getActive().toast('Listing téléphonique (semaine à venir) généré ✅', 'Prévisions', 4);
}








// Calcule la “prochaine prévision” sans peindre la feuille
// Calcule la “prochaine prévision” sans peindre la feuille
function computeNextForecastForBlock_(sheet, row1Abs) {
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastCol < 3) return null;

  const { plages } = getPlagesCachedForSheet_(sheet);
  const startCol = Math.max(3, getNextWeekStartCol_(sheet));  // S+1
  const startIdx = startCol - 3;

  let visibleStartDate = null;
  for (let j = startIdx; j < plages.length; j++) { if (plages[j]) { visibleStartDate = plages[j].start; break; } }
  if (!visibleStartDate) return null;

  const contrat = (sheet.getRange(row1Abs, COL_CONTRAT).getDisplayValue() || '').trim();
  const freq = getFrequenceFromContrat_(contrat);
  if (!freq) return null;

  const widthData = lastCol - 2;
  const row1Vals  = sheet.getRange(row1Abs,     3, 1, widthData).getValues()[0];
  const row1Disp  = sheet.getRange(row1Abs,     3, 1, widthData).getDisplayValues()[0];
  const row2Disp  = sheet.getRange(row1Abs + 1, 3, 1, widthData).getDisplayValues()[0];

  const infoLast = getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
  const lastDate = infoLast ? infoLast.date : null;

  // S+1 doit être la première colonne candidate selon la fréquence + être vide
  const isFilledAt = (j) => (String(row1Disp[j] || '').trim() !== '' || String(row2Disp[j] || '').trim() !== '');
  const s1IsCandidate = (
    (freq === 'WEEKLY'   && !isFilledAt(startIdx)) ||
    (freq === 'BIWEEKLY' && ( (infoLast && ((startCol - infoLast.col) % 2) === 0) || (!infoLast) ) && !isFilledAt(startIdx)) ||
    (freq === 'MONTHLY'  && (function(){
      let anchorDate = lastDate ? addMonths_(lastDate, 1) : visibleStartDate;
      if (anchorDate < visibleStartDate) anchorDate = visibleStartDate;
      const j = findColumnIndexForDate_(plages, anchorDate);
      return (j === startIdx && !isFilledAt(startIdx));
    })())
  );
  if (!s1IsCandidate) return null;

  const firstCol  = startCol;
  const jTarget   = startIdx;
  const firstPlg  = plages[jTarget];
  const firstDate = firstPlg ? firstPlg.start : null;
  if (!firstPlg) return null;

  // Nouveau client : BLEU si aucune planification à partir de S+1
  if (!lastDate) {
    const hasFuturePlanif = hasPlanifFromIndex_(row1Disp, row2Disp, jTarget);
    if (hasFuturePlanif) return null;
    return { firstCol, firstDate, firstColor: FORECAST_BG_NEW, lastDate: null };
  }

  // Autres cas : n’annoncer que si dueDate ≤ fin de S+1
  let dueDate = null;
  if      (freq === 'WEEKLY')   dueDate = addDays_(lastDate, 7);
  else if (freq === 'BIWEEKLY') dueDate = addDays_(lastDate, 14);
  else if (freq === 'MONTHLY')  dueDate = addMonths_(lastDate, 1);
  if (!dueDate || dueDate > firstPlg.end) return null;

  // Couleur selon retard à S+1
  let firstColor = FORECAST_BG_OK;
  let weeksBehind = 0;
  const dueIdx = findColumnIndexForDate_(plages, dueDate);
  if (dueIdx >= 0) {
    weeksBehind = Math.max(0, jTarget - dueIdx);
  } else {
    const ms = 24*60*60*1000;
    weeksBehind = Math.max(0, Math.floor((firstDate - dueDate) / ms / 7));
  }
  if (weeksBehind >= 2)      firstColor = FORECAST_BG_URGENT;
  else if (weeksBehind === 1) firstColor = FORECAST_BG;

  return { firstCol, firstDate, firstColor, lastDate };
}






/***** AIDE – normalisation téléphone (préserve le 0, gère +33/0033) *****/
function normalizePhoneForListing_(raw) {
  if (!raw) return '';
  let s = String(raw).trim();
  let digits = s.replace(/\D/g, '');

  // FR: enlève indicatifs +33 / 0033
  if (digits.startsWith('0033')) digits = digits.slice(4);
  else if (digits.startsWith('33')) digits = digits.slice(2);

  // 9 chiffres → on remet le 0 perdu
  if (digits.length === 9) digits = '0' + digits;

  // Si trop long, garde les 10 derniers (cas copies avec espaces accidentels)
  if (digits.length > 10) digits = digits.slice(-10);

  // Format cible
  if (digits.length !== 10) return s; // fallback si données exotiques
  return digits.replace(/(\d{2})(?=\d)/g, '$1 ').trim();
}


/***** LISTING PRÉVISIONS – Mise en forme FEUILLE (adapté aux 6 colonnes) *****/
function styliserListingPrevisions_(sh, totalCols, groupMeta) {
  const lastRow = sh.getLastRow();
  if (lastRow < 1) return;

  const rngAll = sh.getRange(1, 1, lastRow, totalCols);
  rngAll.setFontFamily('Arial').setFontSize(11).setVerticalAlignment('middle');

  // Nouveaux index colonnes (sans « Priorité »)
  const COL_STAT   = 1; // Statut
  const COL_NOM    = 2; // Nom
  const COL_PRENOM = 3; // Prénom
  const COL_CONTRAT= 4; // Contrat
  const COL_TEL    = 5; // Téléphone
  const COL_LAST   = 6; // Dernière intervention

  // Largeurs
  sh.setColumnWidth(COL_STAT,   300);
  sh.setColumnWidth(COL_NOM,    200);
  sh.setColumnWidth(COL_PRENOM, 160);
  sh.setColumnWidth(COL_CONTRAT,220);
  sh.setColumnWidth(COL_TEL,    150);
  sh.setColumnWidth(COL_LAST,   140);

  // En-tête
  const headerRange = sh.getRange(1, 1, 1, totalCols);
  headerRange
    .setBackground('#EAF6FF')
    .setFontColor('#0F172A')
    .setFontSize(12)
    .setFontWeight('bold')
    .setBorder(true,true,true,true,true,true,'#94D4FF',SpreadsheetApp.BorderStyle.SOLID);

  // Valeurs d'en-tête (rappel)
  sh.getRange(1, COL_TEL).setValue('📞 Téléphone');
  sh.getRange(1, COL_LAST).setValue('📅 Dernière intervention');

  // Lignes de section (groupes) : fusion A:F + fond selon groupMeta
  groupMeta.forEach(g => {
    const r = g.headerRow;
    const sec = sh.getRange(r, 1, 1, totalCols);
    sec.merge();
    sec.setFontWeight('bold').setFontSize(11).setHorizontalAlignment('left').setWrap(true);
    sec.setBackground(g.color || '#E5E7EB').setFontColor('#111827');
    // Bordures de séparation
    sec.setBorder(true,true,true,true,true,true,'#CBD5E1',SpreadsheetApp.BorderStyle.SOLID);
  });

  // Bordure tableau (optionnel)
  sh.getRange(1, 1, lastRow, totalCols)
    .setBorder(true,true,true,true,false,false,'#CBD5E1',SpreadsheetApp.BorderStyle.SOLID);

  // Règles conditionnelles simples sur la colonne Statut
  const rangeStatut = sh.getRange(2, COL_STAT, Math.max(0, lastRow - 1), 1);
  const rules = sh.getConditionalFormatRules().filter(r => {
    const rs = r.getRanges().map(x => x.getA1Notation()).join(',');
    return !rs; // on nettoie agressif (ou adapte si tu veux conserver d'autres règles)
  });

  const ruleUrgent = SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains('Très urgent').setBackground(FORECAST_BG_URGENT).setRanges([rangeStatut]).build();
  const ruleRetard1 = SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains('Retard 1 semaine').setBackground(FORECAST_BG).setRanges([rangeStatut]).build();
  const ruleOk = SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains('Dans le délai').setBackground(FORECAST_BG_OK).setRanges([rangeStatut]).build();
  const ruleNew = SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains('Nouveau client').setBackground(FORECAST_BG_NEW).setRanges([rangeStatut]).build();
  const ruleNone = SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains('Aucune surbrillance').setBackground('#E5E7EB').setRanges([rangeStatut]).build();

  sh.setConditionalFormatRules(rules.concat([ruleUrgent, ruleRetard1, ruleOk, ruleNew, ruleNone]));

  // Hauteurs
  sh.setRowHeight(1, 34);
  for (let r = 2; r <= lastRow; r++) sh.setRowHeight(r, 28);

  // Nettoyage colonnes excédentaires
  const maxCols2 = sh.getMaxColumns();
  if (maxCols2 > totalCols) sh.deleteColumns(totalCols + 1, maxCols2 - totalCols);
}





/************
  NORMALISATION DES TÉLÉPHONES (toutes feuilles)
*************/


/** Normalise tous les numéros (A..B) en texte, format FR “00 00 00 00 00”. */

function normaliserTelephonesToutesFeuilles() {
  // Respecte ta contrainte : ne pas réactiver les prévisions automatiquement
  desactiverPrevisionsAutoSiActives_();

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let totalCorriges = 0, totalVus = 0;

  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(name => {
    const sh = ss.getSheetByName(name);
    if (!sh) return;
    const r = normaliserTelephonesDansFeuille_(sh);
    totalCorriges += r.corriges;
    totalVus += r.vus;
  });

  SpreadsheetApp.getActive().toast(
    `Téléphones normalisés : ${totalCorriges}/${totalVus} cellules corrigées`,
    'Gestion client', 5
  );
}

// --- 2) Normalisation dans les feuilles clients (menu "Normaliser tous les téléphones 📱") ---
function normaliserTelephonesDansFeuille_(sheet) {
  const lastRow = sheet.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < COL_TEL) return { corriges: 0, vus: 0 };

  let corriges = 0, vus = 0;

  // On lit la colonne B (téléphone) de TOUTE la zone données une seule fois
  const count = lastRow - FIRST_DATA_ROW + 1;
  const dispCol = sheet.getRange(FIRST_DATA_ROW, COL_TEL, count, 1).getDisplayValues().map(r => r[0]);
  const rawCol  = sheet.getRange(FIRST_DATA_ROW, COL_TEL, count, 1).getValues().map(r => r[0]);

  // On prépare les lignes (absolues) à réécrire + les nouvelles valeurs
  const rowsToWrite = [];
  const valuesByRow = new Map(); // rowAbs -> string

  for (let r1 = FIRST_DATA_ROW; r1 <= lastRow; r1 += NB_ROWS_BLOCK) {
    const telRow = r1 + 1;
    if (telRow > lastRow) break;

    const idx = telRow - FIRST_DATA_ROW;     // index dans dispCol/rawCol
    const disp = (dispCol[idx] || '').trim();
    const raw  = rawCol[idx];

    if (disp === '' && (raw === '' || raw == null)) { vus++; continue; }

    const base = (typeof raw === 'number') ? String(Math.floor(raw)) : String(disp || raw || '');
    const normalized = normalizePhoneForListing_(base);

    vus++;
    const digitsInDisp = disp.replace(/\D/g, '');
    const mustRewrite  = (normalized !== disp) || (digitsInDisp.length === 9 || digitsInDisp.length === 10);

    if (mustRewrite) {
      rowsToWrite.push(telRow);
      valuesByRow.set(telRow, normalized);
      corriges++;
    }
  }

  if (rowsToWrite.length > 0) {
    // 1) Met le format texte sur TOUTES les cellules cibles en 1 appel RangeList
    const a1s = rowsToWrite.map(r => sheet.getRange(r, COL_TEL).getA1Notation());
    try { sheet.getRangeList(a1s).setNumberFormat('@'); } catch (_) {}

    // 2) Écrit les valeurs par segments contigus (moins d’appels que cellule par cellule)
    const runs = (function toRuns(arr) {
      const a = Array.from(new Set(arr)).sort((x, y) => x - y);
      if (!a.length) return [];
      const out = [];
      let s = a[0], p = a[0];
      for (let i = 1; i < a.length; i++) {
        if (a[i] === p + 1) { p = a[i]; continue; }
        out.push([s, p]); s = p = a[i];
      }
      out.push([s, p]);
      return out;
    })(rowsToWrite);

    runs.forEach(([rStart, rEnd]) => {
      const h = rEnd - rStart + 1;
      const block = Array.from({ length: h }, (_, k) => [ valuesByRow.get(rStart + k) ]);
      sheet.getRange(rStart, COL_TEL, h, 1).setValues(block);
    });
  }

  return { corriges, vus };
}





/***** LISTING PRÉVISIONS – VERSION DIALOG + EXPORT *****/

// Ouvre la grande boîte de dialogue avec la liste déjà rendue en HTML
function ouvrirListingPrevisionsDialog() {
  const t = HtmlService.createTemplateFromFile('listingPrevisionsDialog');
  const html = t.evaluate()
    .setWidth(1100)   // ← élargi
    .setHeight(820);  // ← plus haut
  SpreadsheetApp.getUi().showModalDialog(html, 'Listing téléphonique (priorisé) 📞');
}



// Rassemble les données (même logique que ton générateur de feuille)
function getListingPrevisionsData_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const groups = {
    'Extrême': [],
    'Élevé': [],
    'Moyenne': [],
    'Faible': [],
    'Non prioritaire': []
  };

  const sheet = ss.getSheetByName(SHEET_CLIENTS);
  if (!sheet) return { groups, total: 0 };

  const lastRow = sheet.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return { groups, total: 0 };

  const height = lastRow - (FIRST_DATA_ROW - 1);
  const width  = lastCol - (FIRST_DATA_COL - 1);

  const ABdisp     = sheet.getRange(FIRST_DATA_ROW, 1, height, 2).getDisplayValues();
  const rowValsAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getValues();
  const rowDispAll = sheet.getRange(FIRST_DATA_ROW, FIRST_DATA_COL, height, width).getDisplayValues();

  const { plages } = getPlagesCachedForSheet_(sheet);

  const nextWeekCol = getNextWeekStartCol_(sheet);
  const startCol    = Math.max(FIRST_DATA_COL, nextWeekCol);
  const jS1         = startCol - FIRST_DATA_COL;
  const s1Plage     = plages[jS1];
  if (!s1Plage) return { groups, total: 0 };

  const isFilledAt = (r1, r2, j) => (String(r1[j] || '').trim() !== '' || String(r2[j] || '').trim() !== '');

  const pushNonPrio = (arr, nom, prenom, contrat, tel, lastDate, rank, nextPlanifDate) => {
    arr.push({
      nom, prenom, contrat, tel, lastDate, rank,
      statutLabel: 'Aucune surbrillance (semaine à venir)',
      planifieFutur: !!nextPlanifDate,
      nextPlanifDate
    });
  };

  for (let r1rel = 0; r1rel < height; r1rel += NB_ROWS_BLOCK) {
    const r2rel = r1rel + 1; if (r2rel >= height) break;

    const nom    = (ABdisp[r1rel][0] || '').trim();
    const prenom = (ABdisp[r2rel][0] || '').trim();
    if (!nom) continue;

    const contrat = (ABdisp[r1rel][1] || '').trim();
    const telRaw  = (ABdisp[r2rel][1] || '').trim();
    const tel     = normalizePhoneForListing_(telRaw);
    const rank    = contratOrderRank_(contrat);
    const freq    = getFrequenceFromContrat_(contrat);

    const row1Vals = rowValsAll[r1rel];
    const row1Disp = rowDispAll[r1rel];
    const row2Disp = rowDispAll[r2rel];

    // Détecte une planification FUTURE (info complémentaire)
    let nextPlanifDate = null;
    for (let j = 0; j < plages.length; j++) {
      const p = plages[j]; if (!p) continue;
      const pStart = new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate());
      if (pStart > todayMidnight_() && (isPlanifieMark_(row1Disp[j]) || isPlanifieMark_(row2Disp[j]))) {
        if (!nextPlanifDate || pStart < nextPlanifDate) nextPlanifDate = pStart;
      }
    }

    if (!freq) { pushNonPrio(groups['Non prioritaire'], nom, prenom, contrat, tel, null, rank, nextPlanifDate); continue; }
    if (isFilledAt(row1Disp, row2Disp, jS1)) { pushNonPrio(groups['Non prioritaire'], nom, prenom, contrat, tel, null, rank, nextPlanifDate); continue; }

    const infoLast = getLastInterventionConsideringCurrentWeek_(plages, row1Vals, row1Disp, row2Disp);
    const lastDate = infoLast ? infoLast.date : null;

    // NOUVEAU CLIENT : BLEU si aucune planification à partir de S+1
    if (!lastDate) {
      const hasFuturePlanif = hasPlanifFromIndex_(row1Disp, row2Disp, jS1);
      if (hasFuturePlanif) { // déjà programmé → non prioritaire
        pushNonPrio(groups['Non prioritaire'], nom, prenom, contrat, tel, null, rank, nextPlanifDate);
      } else {
        groups['Extrême'].push({
          nom, prenom, contrat, tel, lastDate: null, rank,
          statutLabel: 'Nouveau client (aucune intervention passée)',
          planifieFutur: false,
          nextPlanifDate: null
        });
      }
      continue;
    }

    // Autres cas : prioritaire UNIQUEMENT si dueDate ≤ fin de S+1
    let dueDate = null;
    if      (freq === 'WEEKLY')   dueDate = addDays_(lastDate, 7);
    else if (freq === 'BIWEEKLY') dueDate = addDays_(lastDate, 14);
    else if (freq === 'MONTHLY')  dueDate = addMonths_(lastDate, 1);
    if (!dueDate || dueDate > s1Plage.end) { pushNonPrio(groups['Non prioritaire'], nom, prenom, contrat, tel, lastDate, rank, nextPlanifDate); continue; }

    let color, weeksBehind = 0;
    const dueIdx = findColumnIndexForDate_(plages, dueDate);
    if (dueIdx >= 0) {
      weeksBehind = Math.max(0, jS1 - dueIdx);
    } else {
      const ms = 24*60*60*1000;
      weeksBehind = Math.max(0, Math.floor((s1Plage.start - dueDate) / ms / 7));
    }
    if (weeksBehind >= 2)      color = FORECAST_BG_URGENT;
    else if (weeksBehind === 1) color = FORECAST_BG;
    else                        color = FORECAST_BG_OK;

    const prio = forecastPriorityInfo_(color);
    groups[prio.label].push({
      nom, prenom, contrat, tel, lastDate, rank,
      statutLabel: prio.statutLabel,
      planifieFutur: !!nextPlanifDate,
      nextPlanifDate
    });
  }

  // Tri par rang puis A→Z
  Object.keys(groups).forEach(k => {
    groups[k].sort((a, b) =>
      (a.rank - b.rank) ||
      a.nom.localeCompare(b.nom) ||
      a.prenom.localeCompare(b.prenom)
    );
  });

  const total = Object.values(groups).reduce((acc, arr) => acc + arr.length, 0);
  return { groups, total };
}














function renderSimpleListingHtml_(data) {
  const cNew  = FORECAST_BG_NEW;
  const cUrg  = FORECAST_BG_URGENT;
  const cRet  = FORECAST_BG;
  const cOk   = FORECAST_BG_OK;
  const cNone = '#E5E7EB';

  function esc(s){
    return String(s||'').replace(/[&<>"']/g, c => (
      {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]
    ));
  }

  // Badges contrat
  function badgeContratHTML(contrat) {
    const t = String(contrat||'').trim();
    if (!t) return '';
    const f = getFrequenceFromContrat_(t); // WEEKLY / BIWEEKLY / MONTHLY / null
    let cls = 'badge-default';
    if (f === 'WEEKLY')        cls = 'badge-weekly';
    else if (f === 'BIWEEKLY') cls = 'badge-biweekly';
    else if (f === 'MONTHLY')  cls = 'badge-monthly';
    return `<span class="badge ${cls}">${esc(t)}</span>`;
  }
  // Badge "Planifié" (violet)
  function badgePlanifieHTML() {
    return `<span class="badge badge-planifie" title="Attention ! Ce client a déjà une intervention future planifiée">Planifié</span>`;
  }

  // === 6 colonnes ===
  function section(title, color, rows) {
    if (!rows || !rows.length) return '';
    const head = `<tr class="section"><th colspan="6" style="background:${color};padding:10px 8px;">${esc(title.toUpperCase())} — ${rows.length} client(s)</th></tr>`;
    const body = rows.map(r =>
      `<tr>
        <td>
          ${esc(r.statutLabel)}
          ${
            r.planifieFutur
              ? `<div class="note-planifie-row">
                   <span class="note-planifie">
                     Attention ! Ce client a déjà une intervention future planifiée${
                       r.nextPlanifDate ? (' — Planifié le ' + esc(fmtJourMoisCourt_(r.nextPlanifDate))) : ''
                     }
                   </span>
                   ${badgePlanifieHTML()}
                 </div>`
              : ``
          }
        </td>
        <td><strong>${esc(r.nom)}</strong></td>
        <td><strong>${esc(r.prenom)}</strong></td>
        <td>${badgeContratHTML(r.contrat)}</td>
        <td class="tel">${esc(r.tel)}</td>
        <td class="center">${fmtJourMoisLong_(r.lastDate)}</td>
      </tr>`).join('');
    return head + body;
  }

  const extreme = data.groups['Extrême'] || [];
  const elev    = data.groups['Élevé']   || [];
  const moy     = data.groups['Moyenne'] || [];
  const faible  = data.groups['Faible']  || [];
  const none    = data.groups['Non prioritaire'] || [];

  const total        = (data.total || 0);
  const totalPrio    = extreme.length + elev.length + moy.length + faible.length;
  const totalNonPrio = none.length;

  const metaTxt =
    `Semaine à venir — Total: ${total} • ` +
    `Prioritaires: ${totalPrio} • Non prioritaires: ${totalNonPrio} — ` +
    `Détail: Extrême ${extreme.length} · Élevé ${elev.length} · ` +
    `Moyenne ${moy.length} · Faible ${faible.length} · Non prioritaire ${none.length}`;

  return `
<style>
  .listing{width:100%;border-collapse:collapse}
  .listing th,.listing td{border:1px solid #e5e7eb;padding:8px 10px;text-align:left;vertical-align:middle}
  .listing thead th{background:#f7f7f7;font-weight:700}
  .center{text-align:center}
  .tel{font-weight:700;text-align:center;background:#E8F5E9}
  .meta{margin:6px 0 10px;color:#475569;font-size:13px}
  .legend{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px;font-size:12px;color:#475569}
  .dot{display:inline-block;width:10px;height:10px;border-radius:50%;vertical-align:middle;margin-right:6px}
  .section th{font-weight:700;text-align:center;border-color:#8B8B8B}

  /* Badges */
  .badge{display:inline-block;padding:.2rem .55rem;border-radius:999px;font-size:12px;font-weight:700;line-height:1;border:1px solid transparent}
  .badge-weekly{background:#e0f2fe;border-color:#bae6fd;color:#0c4a6e}
  .badge-biweekly{background:#fff7ed;border-color:#fed7aa;color:#9a3412}
  .badge-monthly{background:#ecfdf5;border-color:#bbf7d0;color:#166534}
  .badge-default{background:#f1f5f9;border-color:#cbd5e1;color:#334155}
  .badge-planifie{background:#ede9fe;border-color:#c4b5fd;color:#5b21b6}

  /* Mention + badge sur la même ligne */
  .note-planifie-row{display:inline-flex;align-items:center;gap:8px;margin-top:2px}
  .note-planifie{color:#6d28d9;font-weight:700;font-size:12px}
</style>
<div class="legend">
  <span><span class="dot" style="background:${cNew}"></span>Nouveau client</span>
  <span><span class="dot" style="background:${cUrg}"></span>Très urgent (≥ 2 sem. de retard)</span>
  <span><span class="dot" style="background:${cRet}"></span>Retard 1 semaine</span>
  <span><span class="dot" style="background:${cOk}"></span>Dans le délai</span>
  <span><span class="dot" style="background:${cNone}"></span>Non prioritaire (pas de surbrillance la semaine à venir)</span>
</div>
<div class="meta">${esc(metaTxt)}</div>
<table class="listing">
  <thead>
    <tr>
      <th>Statut</th>
      <th>Nom</th>
      <th>Prénom</th>
      <th>Contrat</th>
      <th>📞 Téléphone</th>
      <th>📅 Dernière intervention</th>
    </tr>
  </thead>
  <tbody>
    ${section('Extrême', cNew, extreme)}
    ${section('Élevé',   cUrg, elev)}
    ${section('Moyenne', cRet, moy)}
    ${section('Faible',  cOk,  faible)}
    ${section('Non prioritaire', cNone, none)}
  </tbody>
</table>`;
}














function wrapStandaloneHtml_(inner) {
  const favSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="52">📞</text></svg>';
  const fav = 'data:image/svg+xml,' + encodeURIComponent(favSvg);

  return (
    '<!DOCTYPE html><html><head><meta charset="utf-8">' +
    '<meta name="viewport" content="width=device-width, initial-scale=1">' +
    '<title>📞 Listing téléphonique – semaine à venir</title>' +
    '<link rel="icon" type="image/svg+xml" sizes="any" href="'+fav+'">' +
    '<link rel="shortcut icon" type="image/svg+xml" href="'+fav+'">' +
    '<link rel="apple-touch-icon" href="'+fav+'">' +
    '<style>' +
      'body{margin:16px;background:#f1f5f9;font-family:Arial,Helvetica,sans-serif}' +
      '.badge{display:inline-block;padding:.2rem .55rem;border-radius:999px;font-size:12px;font-weight:700;line-height:1;border:1px solid transparent}' +
      '.badge-weekly{background:#e0f2fe;border-color:#bae6fd;color:#0c4a6e}' +
      '.badge-biweekly{background:#fff7ed;border-color:#fed7aa;color:#9a3412}' +
      '.badge-monthly{background:#ecfdf5;border-color:#bbf7d0;color:#166534}' +
      '.badge-default{background:#f1f5f9;border-color:#cbd5e1;color:#334155}' +
    '</style>' +
    '</head><body>' + inner + '</body></html>'
  );
}




// Protège le HTML de base (nom, prénom, contrat, téléphone)
function escapeHtml_(s) {
  return String(s || '')
    .replace(/&/g,'&amp;').replace(/</g,'&lt;')
    .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
}

// Renvoie l'HTML complet (pour ouverture en onglet)
function getListingPrevisionsStandaloneHtml() {
  const data = getListingPrevisionsData_();
  const body = renderSimpleListingHtml_(data); // fragment
  return wrapStandaloneHtml_(body);            // page complète
}


// Génère un PDF sur Drive et renvoie {url, name}
function exportListingPrevisionsPdf(opts) {
  const share = !(opts && opts.share === false); // défaut = partagé

  const data = getListingPrevisionsData_();
  const body = renderSimpleListingHtml_(data);
  const html = wrapStandaloneHtml_(body);

  const blob = Utilities.newBlob(html, 'text/html', 'listing.html').getAs('application/pdf');
  const name = '📞 Listing Téléphone (semaine à venir) - ' +
    Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd_HHmm') + '.pdf';
  blob.setName(name);

  const file = DriveApp.createFile(blob);
  if (share) {
    try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (_) {}
  }
  return { url: file.getUrl(), name };
}




function wrapStandaloneHtmlForPdf_(inner) {
  const favSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="52">📞</text></svg>';
  const fav = 'data:image/svg+xml,' + encodeURIComponent(favSvg);

  return (
    '<!DOCTYPE html><html><head><meta charset="utf-8">' +
    '<meta name="viewport" content="width=device-width, initial-scale=1">' +
    '<title>📞 Listing téléphonique – semaine à venir</title>' +
    '<link rel="icon" type="image/svg+xml" sizes="any" href="'+fav+'">' +
    '<link rel="shortcut icon" type="image/svg+xml" href="'+fav+'">' +
    '<link rel="apple-touch-icon" href="'+fav+'">' +
    '<style>' +
      '@page { size: A4; margin: 14mm; }' +
      'html,body{margin:0;background:#ffffff;font:14px/1.45 Arial,Helvetica,sans-serif;-webkit-print-color-adjust: exact; print-color-adjust: exact;}' +
      'table,th,td{ -webkit-print-color-adjust: exact; print-color-adjust: exact; }' +
      '.listing{width:100%;border-collapse:collapse}' +
      '.listing th,.listing td{border:1px solid #e5e7eb;padding:8px 10px;text-align:left;vertical-align:middle}' +
      '.listing thead th{background-color:#f7f7f7 !important;font-weight:700}' +
      '.center{text-align:center}' +
      '.tel{font-weight:700;text-align:center;background-color:#E8F5E9 !important}' +
      '.meta{margin:6px 0 10px;color:#475569;font-size:13px}' +
      '.legend{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px;font-size:12px;color:#475569}' +
      '.dot{display:inline-block;width:10px;height:10px;border-radius:50%;vertical-align:middle;margin-right:6px}' +
      '.section th{font-weight:700;text-align:center;border-color:#8B8B8B}' +
      '.badge{display:inline-block;padding:.2rem .55rem;border-radius:999px;font-size:12px;font-weight:700;line-height:1;border:1px solid transparent}' +
      '.badge-weekly{background:#e0f2fe !important;border-color:#bae6fd !important;color:#0c4a6e !important}' +
      '.badge-biweekly{background:#fff7ed !important;border-color:#fed7aa !important;color:#9a3412 !important}' +
      '.badge-monthly{background:#ecfdf5 !important;border-color:#bbf7d0 !important;color:#166534 !important}' +
      '.badge-default{background:#f1f5f9 !important;border-color:#cbd5e1 !important;color:#334155 !important}' +
    '</style>' +
    '</head><body>' + inner + '</body></html>'
  );
}



/**
 * Reçoit le fragment HTML rendu dans la boîte de dialogue (groups déjà triés)
 * ➜ génère un PDF en couleurs SANS créer de feuille.
 * Retourne {url, name}
 */
function exportListingPrevisionsPdfFromHtml(htmlFragment, opts) {
  if (!htmlFragment) throw new Error('Fragment HTML manquant.');
  const share = !(opts && opts.share === false);

  const html = wrapStandaloneHtmlForPdf_(htmlFragment);
  const blobPdf = Utilities.newBlob(html, 'text/html', 'listing.html').getAs('application/pdf');

  const name = 'Listing Téléphone (semaine à venir) - ' +
    Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd_HHmm') + '.pdf';
  blobPdf.setName(name);

  const file = DriveApp.createFile(blobPdf);
  if (share) {
    try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (_) {}
  }
  return { url: file.getUrl(), name };
}




/**
 * Exporte la feuille "Listing Prévisions 📞" en PDF (couleurs conservées).
 * Si la feuille n'existe pas ou n'est pas à jour, on la régénère avant.
 * Retourne {url, name}.
 */
function exportListingPrevisionsPdfFromSheet(opts) {
  const share = !(opts && opts.share === false);

  try { genererListingTelephoniquePrevisions(); } catch(e) { Logger.log(e); }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(LISTING_SHEET_NAME);
  if (!sh) throw new Error('Feuille "' + LISTING_SHEET_NAME + '" introuvable.');

  const pdfBlob = exportSheetAsPdf_(ss, sh);
  const fileName = '📞 Listing Téléphone (semaine à venir) - ' +
    Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd_HHmm') + '.pdf';

  pdfBlob.setName(fileName);
  const file = DriveApp.createFile(pdfBlob);
  if (share) {
    try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch(_) {}
  }
  return { url: file.getUrl(), name: fileName };
}


/**
 * Exporte une feuille précise d'un classeur en PDF (A4 portrait, fit width).
 */
function exportSheetAsPdf_(ss, sheet) {
  const exportUrl = 'https://docs.google.com/spreadsheets/d/' + ss.getId() + '/export';
  const params = {
    format: 'pdf',
    gid: sheet.getSheetId(),
    size: 'A4',
    portrait: 'true',
    fitw: 'true',
    top_margin: '0.5',
    right_margin: '0.5',
    bottom_margin: '0.5',
    left_margin: '0.5',
    gridlines: 'false',
    printtitle: 'false',
    sheetnames: 'false',
    pagenumbers: 'false',
    fzr: 'false' // freeze rows as title
  };
  const query = Object.keys(params).map(k => k + '=' + encodeURIComponent(params[k])).join('&');
  const token = ScriptApp.getOAuthToken();
  const res = UrlFetchApp.fetch(exportUrl + '?' + query, {
    headers: { Authorization: 'Bearer ' + token },
    muteHttpExceptions: true
  });
  if (res.getResponseCode() !== 200) throw new Error('Export PDF échoué: ' + res.getContentText());
  return res.getBlob();
}

// Renvoie le fragment HTML du listing (appelé par le HTML via google.script.run)
function getListingPrevisionsHtmlFragment() {
  const data = getListingPrevisionsData_();
  return renderSimpleListingHtml_(data);
}


/** Rend le fragment HTML (table) de la synthèse à partir des données calculées. */
/** Rend le fragment HTML (table) de la synthèse à partir des données calculées. */
function renderSyntheseHtmlFragment_(data) {
  function esc(s){
    return String(s||'').replace(/[&<>"']/g, c => (
      {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]
    ));
  }
  // Mois en lettres (ex. "Août 2025")
  const moisTxt = moisFr_(data.mois) + ' ' + data.annee;

  // Ligne meta : total clients, clients à facturer, total transports
  const metaTxt = `${data.nbClientsTotal} client(s) — ${data.nbClientsActifs} à facturer — ${data.totalGlobal} transport(s)`;

  function badgeContratHTML(contrat) {
    const t = String(contrat||'').trim();
    if (!t) return '';
    const isPonct = /ponctuel/i.test(t);
    const cls = isPonct ? 'badge badge-ponctuel' : 'badge badge-regulier';
    return `<span class="${cls}">${esc(t)}</span>`;
  }

  // 🔒 Tri UNIQUE A → Z sur le nom du client
  const rowsAZ = (data.lignes || [])
    .slice()
    .sort((a, b) => (a.client || '').localeCompare(b.client || ''));

  const body = rowsAZ.map(r=>{
    const ok = (r.total||0) > 0 ? ' ok' : '';
    return `<tr>
      <td>${esc(r.client)}</td>
      <td>${badgeContratHTML(r.contrat)}</td>
      <td class="num${ok}">${r.total||0}</td>
    </tr>`;
  }).join('');

  const totalRow = `<tr class="tfoot">
    <td colspan="2"><strong>Totaux</strong></td>
    <td class="num ok"><strong>${data.totalGlobal}</strong></td>
  </tr>`;

  return `
  <div class="moisTitle"><strong>${moisTxt}</strong></div>
  <div class="meta">${metaTxt}</div>
  <div class="tableWrap">
    <table class="syn" id="synTable">
      <thead>
        <tr>
          <th>Client (A → Z)</th>
          <th>Contrat</th>
          <th>Total transports</th>
        </tr>
      </thead>
      <tbody>${body || ''}</tbody>
      <tfoot>${totalRow}</tfoot>
    </table>
  </div>`;
}





/** Page complète (aperçu plein onglet) avec styles écran. */
function wrapStandaloneHtmlSynthese_(inner) {
  const favSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="52">🚛</text></svg>';
  const fav = 'data:image/svg+xml,' + encodeURIComponent(favSvg);

  return '<!DOCTYPE html><html><head><meta charset="utf-8">' +
    '<meta name="viewport" content="width=device-width, initial-scale=1">' +
    '<title>🚛 Synthèse – Transports mensuels</title>' +
    '<link rel="icon" type="image/svg+xml" sizes="any" href="'+fav+'">' +
    '<link rel="shortcut icon" type="image/svg+xml" href="'+fav+'">' +
    '<link rel="apple-touch-icon" href="'+fav+'">' +
    '<style>' +
    ':root{--primary:#0ea5e9;--primary-700:#0284c7;--bg:#f1f5f9;--card:#ffffff;--text:#0f172a;--sub:#475569;--border:#e2e8f0;--thead:#f8fafc;--accent:#16a34a}' +
    'html,body{background:var(--bg);color:var(--text);font-family:Arial,Helvetica,sans-serif;margin:0}' +
    '.titlebar{background:linear-gradient(90deg,var(--primary),#5eead4);color:#fff;padding:14px 16px;font-weight:700;letter-spacing:.2px;display:flex;align-items:center;gap:10px;font-size:16px;box-shadow:0 2px 12px rgba(2,132,199,.25)}' +
    '.wrap{padding:16px}' +
    '.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;box-shadow:0 2px 8px rgba(15,23,42,.04)}' +
    '.moisTitle{font-size:18px;margin-bottom:2px}' +
    '.meta{color:var(--sub);font-size:13px;margin:6px 0 10px}' +
    '.tableWrap{max-height:60vh;overflow:auto;border-radius:10px}' +
    'table.syn{width:100%;border-collapse:collapse;background:#fff}' +
    'table.syn th,table.syn td{border:1px solid var(--border);padding:8px 10px;text-align:left;vertical-align:middle}' +
    'table.syn thead th{background:var(--thead);font-weight:700;cursor:pointer;user-select:none}' +
    'table.syn td.num{text-align:center;font-weight:600}' +
    'table.syn td.num.ok{color:var(--accent);font-weight:700}' +
    'tfoot tr.tfoot{position:sticky;bottom:0;background:#fff}' +
    '.badge{display:inline-block;padding:.15rem .5rem;border-radius:999px;font-size:12px;font-weight:600;line-height:1;border:1px solid transparent}' +
    '.badge-ponctuel{background:rgba(245,158,11,.12);color:#92400e;border-color:rgba(245,158,11,.3)}' +
    '.badge-regulier{background:rgba(59,130,246,.12);color:#1e40af;border-color:rgba(59,130,246,.3)}' +
    '</style>' +
    '</head><body>' +
    '<div class="titlebar">🚛 Synthèse – Transports mensuels</div>' +
    '<div class="wrap"><div class="card"><div id="content">' + inner + '</div></div></div>' +
    '<script>' +
    '(function(){var t=document.getElementById("synTable");if(!t)return;var ths=t.querySelectorAll("thead th");ths.forEach(function(th,i){th.addEventListener("click",function(){var dir=(th.dataset.dir==="asc")?-1:1;ths.forEach(h=>h.removeAttribute("data-dir"));th.setAttribute("data-dir",dir>0?"asc":"desc");var tbody=t.querySelector("tbody");var rows=[].slice.call(tbody.querySelectorAll("tr"));rows.sort(function(a,b){var A=a.children[i].textContent.trim();var B=b.children[i].textContent.trim();if(i===2){A=+A||0;B=+B||0;}return (A>B?1:A<B?-1:0)*dir;});rows.forEach(r=>tbody.appendChild(r));});});})();' +
    '</script>' +
    '</body></html>';
}




/** Page complète optimisée impression/PDF (couleurs conservées). */
function wrapStandaloneHtmlForPdfSynthese_(inner) {
  return '<!DOCTYPE html><html><head><meta charset="utf-8">' +
    '<meta name="viewport" content="width=device-width, initial-scale=1">' +
    '<title>🚛 Synthèse – Transports mensuels</title>' +   // ← même titre que l’HTML
    '<style>' +
    '@page{size:A4;margin:14mm}' +
    'html,body{margin:0;background:#ffffff;font:14px/1.45 Arial,Helvetica,sans-serif;-webkit-print-color-adjust:exact;print-color-adjust:exact}' +
    'table,th,td{-webkit-print-color-adjust:exact;print-color-adjust:exact}' +
    '.moisTitle{font-size:18px;margin-bottom:2px;font-weight:700}' +
    '.meta{margin:6px 0 10px;color:#475569;font-size:13px}' +
    'table.syn{width:100%;border-collapse:collapse}' +
    'table.syn th,table.syn td{border:1px solid #e5e7eb;padding:8px 10px;text-align:left;vertical-align:middle}' +
    'table.syn thead th{background:#f8fafc !important;font-weight:700}' +
    'table.syn td.num{text-align:center;font-weight:600}' +
    'table.syn td.num.ok{color:#16a34a !important;font-weight:700}' +
    '.badge{display:inline-block;padding:.15rem .5rem;border-radius:999px;font-size:12px;font-weight:600;line-height:1;border:1px solid transparent}' +
    '.badge-ponctuel{background:rgba(245,158,11,.18) !important;color:#92400e !important;border-color:rgba(245,158,11,.35) !important}' +
    '.badge-regulier{background:rgba(59,130,246,.18) !important;color:#1e40af !important;border-color:rgba(59,130,246,.35) !important}' +
    '</style></head><body>' + inner + '</body></html>';
}



/** Donne le fragment HTML (pour la boîte) en recalculant la synthèse. */
function getSyntheseHtmlFragment(opts) {
  const def = getSyntheseDefaults_();
  const mois  = (opts && +opts.mois>=1 && +opts.mois<=12) ? +opts.mois : def.mois;
  const annee = (opts && +opts.annee) ? +opts.annee : def.annee;
  const data = genererSyntheseTransports({ mois, annee });
  return renderSyntheseHtmlFragment_(data);
}

/** Ouvre en plein onglet : renvoie la page HTML complète. */
function getSyntheseStandaloneHtml(opts) {
  const def = getSyntheseDefaults_();
  const mois  = (opts && +opts.mois>=1 && +opts.mois<=12) ? +opts.mois : def.mois;
  const annee = (opts && +opts.annee) ? +opts.annee : def.annee;
  const data = genererSyntheseTransports({ mois, annee });
  const body = renderSyntheseHtmlFragment_(data);
  return wrapStandaloneHtmlSynthese_(body);
}

/** Exporte en PDF (sans créer d’onglet). Retourne {url,name}. */
function exportSynthesePdf(opts) {
  const share = !(opts && opts.share === false);
  try {
    const def = getSyntheseDefaults_();
    const mois  = (opts && +opts.mois>=1 && +opts.mois<=12) ? +opts.mois : def.mois;
    const annee = (opts && +opts.annee) ? +opts.annee : def.annee;

    const data = genererSyntheseTransports({ mois, annee });
    const body = renderSyntheseHtmlFragment_(data);
    const html = wrapStandaloneHtmlForPdfSynthese_(body);

    const blobPdf = Utilities.newBlob(html, 'text/html', 'synthese.html').getAs('application/pdf');
    const fname = '🚛 Synthèse – Transports mensuels - ' + annee + '-' + ('0'+mois).slice(-2) + '.pdf';
    blobPdf.setName(fname);

    const file = DriveApp.createFile(blobPdf);
    if (share) {
      try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (_) {}
    }
    return { url: file.getUrl(), name: fname };
  } catch (e) {
    const msg = (e && e.message) ? e.message : String(e);
    throw new Error('Export PDF impossible. Détail : ' + msg);
  }
}


function forcePlainText_(range) {
  try { range.setNumberFormat('@'); } catch (_) {}
}


function getPlagesCachedForSheet_(sheet) {
  const lastCol = Math.min(NB_COLS_BLOCK, sheet.getLastColumn());
  if (lastCol < FIRST_DATA_COL) return { plages: [], yearRef: getAnneeDeReference_() };

  const width  = lastCol - (FIRST_DATA_COL - 1);
  const year   = getAnneeDeReference_();
  const heads  = sheet.getRange(HEADER_ROWS, FIRST_DATA_COL, 1, width).getDisplayValues()[0];
  const sig    = heads.join(' | ') + ' @Y=' + year;
  const sid    = sheet.getSheetId();
  const prev   = __PLAGES_CACHE.get(sid);

  if (prev && prev.headersSig === sig) return prev;

  const plages = new Array(width).fill(null).map((_, j) => parsePlageDepuisEntete_(heads[j], year) || null);
  const obj = { plages, headersSig: sig, yearRef: year };
  __PLAGES_CACHE.set(sid, obj);
  return obj;
}


function maybeRepaintS1WhenCurrentWeekEdited_(e) {
  if (!isForecastEnabled_()) return;

  const sh = e && e.range && e.range.getSheet();
  if (!sh) return;
  const name = sh.getName();
  if (name !== SHEET_CLIENTS && name !== SHEET_PONCTUEL) return;

  const lastRow = sh.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sh.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  // Colonnes de la semaine COURANTE
  const currWeekCols = computeWeekColsFromHeaders_(sh, todayMidnight_());
  if (!currWeekCols || currWeekCols.length === 0) return;

  // Zone réellement éditée (bornée à la zone data)
  const rng   = e.range;
  const r0    = rng.getRow(), c0 = rng.getColumn();
  const h     = rng.getNumRows(), w = rng.getNumColumns();

  const rStart = Math.max(FIRST_DATA_ROW, r0);
  const rEnd   = Math.min(lastRow, r0 + h - 1);
  const cStart = Math.max(FIRST_DATA_COL, c0);
  const cEnd   = Math.min(lastCol, c0 + w - 1);
  if (rEnd < FIRST_DATA_ROW || cEnd < FIRST_DATA_COL) return;

  // L'édition touche-t-elle AU MOINS UNE colonne de la semaine courante ?
  const touchesCurrentWeek = currWeekCols.some(c => c >= cStart && c <= cEnd);
  if (!touchesCurrentWeek) return;

  // Détermine les blocs (r1 des blocs 2 lignes) impactés par l'édition
  const blocks = new Set();
  for (let r = rStart; r <= rEnd; r++) {
    const r1 = ((r - FIRST_DATA_ROW) % NB_ROWS_BLOCK === 0) ? r : (r - 1);
    blocks.add(r1);
  }
  if (blocks.size === 0) return;

  // Recalcule EN TEMPS RÉEL la couleur de S+1 pour ces blocs
  repaintForecastForBlocksOnEdit_(sh, Array.from(blocks));
}

function maybeKeepCurrentWeekBlueOnEdit_(e) {
  const sh = e && e.range && e.range.getSheet();
  if (!sh) return;
  const name = sh.getName();
  if (name !== SHEET_CLIENTS && name !== SHEET_PONCTUEL) return;

  const currCols = getCurrentWeekCols_(sh);
  if (!currCols || !currCols.length) return;
  const currSet = new Set(currCols);

  const lastRow = sh.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sh.getLastColumn());

  const rng = e.range;
  const r0 = rng.getRow(), c0 = rng.getColumn();
  const h  = rng.getNumRows(), w = rng.getNumColumns();

  const rStart = Math.max(FIRST_DATA_ROW, r0);
  const rEnd   = Math.min(lastRow, r0 + h - 1);
  const cStart = Math.max(FIRST_DATA_COL, c0);
  const cEnd   = Math.min(lastCol, c0 + w - 1);
  if (rEnd < FIRST_DATA_ROW || cEnd < FIRST_DATA_COL) return;

  const a1s = [];
  for (let c = cStart; c <= cEnd; c++) {
    if (!currSet.has(c)) continue;
    a1s.push(sh.getRange(rStart, c, rEnd - rStart + 1, 1).getA1Notation());
  }
  if (a1s.length) sh.getRangeList(a1s).setBackground(HIGHLIGHT_COLUMN_BG);
}


// --- Remplacement complet ---
function maybePrefillStatutWhenDateFirstSet_(e) {
  const sh = e && e.range && e.range.getSheet();
  if (!sh) return;
  const name = sh.getName();
  if (name !== SHEET_CLIENTS && name !== SHEET_PONCTUEL) return;

  const lastRow = sh.getLastRow();
  const lastCol = Math.min(NB_COLS_BLOCK, sh.getLastColumn());
  if (lastRow < FIRST_DATA_ROW || lastCol < FIRST_DATA_COL) return;

  SpreadsheetApp.flush();

  const rng = e.range;
  let rStart = Math.max(FIRST_DATA_ROW, rng.getRow());
  let rEnd   = Math.min(lastRow,        rng.getRow() + rng.getNumRows()    - 1);
  let cStart = Math.max(FIRST_DATA_COL, rng.getColumn());
  let cEnd   = Math.min(lastCol,        rng.getColumn() + rng.getNumColumns() - 1);

  // ⚠️ si édition au-delà de BB (NB_COLS_BLOCK), on n’a rien à faire
  if (rEnd < FIRST_DATA_ROW || cEnd < FIRST_DATA_COL || cStart > cEnd) return;

  for (let rAbs = rStart; rAbs <= rEnd; rAbs++) {
    // uniquement la ligne 1 de chaque bloc (ligne "Date")
    if (((rAbs - FIRST_DATA_ROW) % NB_ROWS_BLOCK) !== 0) continue;
    const r2Abs = rAbs + 1; if (r2Abs > lastRow) continue;

    const topVals    = sh.getRange(rAbs,  cStart, 1, cEnd - cStart + 1).getValues()[0];
    const statutDisp = sh.getRange(r2Abs, cStart, 1, cEnd - cStart + 1).getDisplayValues()[0];

    // colonnes où on doit préremplir (date présente + dans la plage + statut vraiment vide)
    const targets = [];
    for (let cAbs = cStart; cAbs <= cEnd; cAbs++) {
      const dc = cAbs - cStart;
      const dt = __dateLikeOrNull_(topVals[dc]);
      if (!dt) continue;
      if (!__isInHeaderPlage_(sh, cAbs, dt)) continue;
      if (normalize_(String(statutDisp[dc] || '')) !== '') continue; // déjà rempli
      targets.push(cAbs);
    }
    if (!targets.length) continue;

    // écriture par segments contigus, en utilisant le libellé EXACT autorisé par chaque cellule
    const runs = toRuns_(targets);
    runs.forEach(([c1, c2]) => {
      const len = c2 - c1 + 1;
      const row = new Array(len);
      for (let j = 0; j < len; j++) {
        row[j] = getPlanifieCanonForCell_(sh, r2Abs, c1 + j);
      }
      sh.getRange(r2Abs, c1, 1, len).setValues([row]);
    });
  }
}


// --- Helpers pour le préremplissage ---
function __dateLikeOrNull_(v) {
  if (!v) return null;
  if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v.getTime())) return v;
  if (typeof v === 'string') return toDateOrNull_(v);
  return null;
}
function __isInHeaderPlage_(sheet, colAbs, dt) {
  // Retourne true si pas de plage connue (on n’empêche pas), ou si dt ∈ [start,end]
  const info = getPlagesCachedForSheet_(sheet);
  const idx  = colAbs - FIRST_DATA_COL;
  const p    = info && info.plages ? info.plages[idx] : null;
  if (!p || !dt) return true;
  const d = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  const s = new Date(p.start.getFullYear(), p.start.getMonth(), p.start.getDate());
  const e = new Date(p.end.getFullYear(),   p.end.getMonth(),   p.end.getDate());
  return (d >= s && d <= e);
}


// --- NOUVEAU : récupère le libellé "Planifié" EXACT autorisé par la cellule (si liste) ---
function getPlanifieCanonForCell_(sheet, r2Abs, cAbs) {
  try {
    const rng = sheet.getRange(r2Abs, cAbs);
    const rule = rng.getDataValidation && rng.getDataValidation();
    if (rule && rule.getCriteriaType && rule.getCriteriaType() === SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST) {
      const vals = rule.getCriteriaValues && rule.getCriteriaValues();
      if (vals && vals[0] && vals[0].length) {
        const found = vals[0].find(v => {
          const s = String(v || '');
          const n = normalize_(s);
          return s.includes('📆') || /planifi/i.test(n) || /planifiee/i.test(n);
        });
        if (found != null) return String(found);
      }
    }
  } catch (_) {}
  // secours : retombe sur le canon du template / défaut
  return getCanonPlanifieText_();
}

/**
 * Pose une MFC : B3:B vide => fond rouge, sur "Client Régulier" et "Client Ponctuel".
 * À exécuter une seule fois.
 */
function InstallerMiseEnRougeChampsVides() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();

  // Utilise tes constantes si elles existent, sinon les noms par défaut.
  var feuilles = (typeof SHEET_CLIENTS !== 'undefined' && typeof SHEET_PONCTUEL !== 'undefined')
    ? [SHEET_CLIENTS, SHEET_PONCTUEL]
    : ["Client Régulier", "Client Ponctuel"];

  var a1 = "B3:B";
  var rouge = "#FECACA"; // ajuste au besoin
  var formule = "=LEN(TRIM(B3))=0"; // « cellule vide » (y compris espaces)

  feuilles.forEach(function(nom) {
    var sh = ss.getSheetByName(nom);
    if (!sh) return;

    var rules = sh.getConditionalFormatRules() || [];

    // Évite les doublons sur la même plage (B3:B) pour BLANK ou la même formule.
    rules = rules.filter(function(r) {
      try {
        var touchesB = r.getRanges && r.getRanges().some(function(rg){
          return rg.getA1Notation() === a1;
        });
        if (!touchesB) return true;

        var cond = r.getBooleanCondition && r.getBooleanCondition();
        if (!cond) return true;

        var t = cond.getType && cond.getType();
        if (t === SpreadsheetApp.BooleanConditionType.BLANK) return false;

        if (t === SpreadsheetApp.BooleanConditionType.CUSTOM_FORMULA) {
          var vals = cond.getValues && cond.getValues();
          if (vals && vals[0] && String(vals[0]).replace(/\s+/g,'').toUpperCase() === formule.replace(/\s+/g,'').toUpperCase()) {
            return false;
          }
        }
        return true;
      } catch (e) { return true; }
    });

    var regle = SpreadsheetApp.newConditionalFormatRule()
      .whenFormulaSatisfied(formule)   // <- remplace whenBlank()
      .setBackground(rouge)
      .setRanges([sh.getRange(a1)])
      .build();

    rules.push(regle);
    sh.setConditionalFormatRules(rules);
  });
}


function reparerTout_() {
  const ss = SpreadsheetApp.getActive();
  const props = PropertiesService.getDocumentProperties();
  const feuilles = [SHEET_CLIENTS, SHEET_PONCTUEL];

  // 1) Invalider le cache de surbrillance
  feuilles.forEach(n => {
    const sh = ss.getSheetByName(n); if (!sh) return;
    const sid = sh.getSheetId();
    props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX + sid);
    props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + '_' + sid);
  });

  // 2) Repeindre semaine + prévisions éventuelles
  if (typeof surlignerSemaineEnCoursToutesFeuilles_ === 'function') {
    surlignerSemaineEnCoursToutesFeuilles_();
  }

  // 3) Reposer les validations (si tes fonctions existent)
  try { if (typeof resynchroniserValidationsStatutDepuisTemplate === 'function') resynchroniserValidationsStatutDepuisTemplate(); } catch(_){}
  try { if (typeof recalculerValidationsDepuisMenu === 'function') recalculerValidationsDepuisMenu(); } catch(_){}

  // 4) Reposer la MFC "champs vides en rouge" (si tu l’utilises)
  try { if (typeof InstallerMiseEnRougeChampsVides === 'function') InstallerMiseEnRougeChampsVides(); } catch(_){}
  try { SpreadsheetApp.getActiveSpreadsheet().toast('Réparation terminée ✅', 'Script', 5); } catch(_){}
}


function invalidateHighlightCacheForSheet_(sheet) {
  if (!sheet) return;
  const props = PropertiesService.getDocumentProperties();
  const sid = sheet.getSheetId();
  props.deleteProperty(PROP_WEEK_LAST_ROWS_PREFIX + sid);
  props.deleteProperty(PROP_WEEK_BORDER_COLS_PREFIX + '_' + sid);
}

function normaliserTelFR_(raw) {
  if (raw == null) return '';
  let s = String(raw).replace(/[^\d+]/g, '').trim();

  // +33 → 0
  if (s.startsWith('+33')) s = '0' + s.slice(3);
  // 0033 → 0
  if (s.startsWith('0033')) s = '0' + s.slice(4);

  // Garder 10 chiffres (FR) si possible
  const digits = s.replace(/\D/g, '');
  if (digits.length === 9 && !digits.startsWith('0')) s = '0' + digits;
  else if (digits.length === 10) s = digits;
  else return raw.toString(); // ne force pas si autre format (DOM/TOM, pro, etc.)

  // Mise en forme 0X XX XX XX XX
  return s.replace(/^(\d)(\d{1})(\d{2})(\d{2})(\d{2})(\d{2})$/, '$1$2 $3 $4 $5 $6');
}


function normaliserTelephonesToutesFeuilles() {
  const ss = SpreadsheetApp.getActive();
  [SHEET_CLIENTS, SHEET_PONCTUEL].forEach(n => {
    const sh = ss.getSheetByName(n); if (!sh) return;
    const last = sh.getLastRow(); if (last < 3) return;
    const rg = sh.getRange(3, COL_TEL, last-2, 1);
    const vals = rg.getValues();
    let changed = false;
    for (let i=0; i<vals.length; i++) {
      const v = vals[i][0];
      const nv = normaliserTelFR_(v);
      if (nv !== v) { vals[i][0] = nv; changed = true; }
    }
    if (changed) rg.setValues(vals);
  });
}


function surlignerDoublonsClients_() {
  const ss = SpreadsheetApp.getActive();
  const feuilles = [SHEET_CLIENTS, SHEET_PONCTUEL];
  const clés = new Map(); // "NOM|Prénom" -> [ {sheet, row1} ]

  feuilles.forEach(n => {
    const sh = ss.getSheetByName(n); if (!sh) return;
    const last = sh.getLastRow(); if (last < 4) return;
    const A = sh.getRange(3, 1, last-2, 1).getDisplayValues(); // NOM (r1, r3,...)
    const A2= sh.getRange(4, 1, last-3, 1).getDisplayValues(); // PRÉNOM (r2, r4,...)
    for (let r=3; r<=last-1; r+=2) {
      const nom = (A[r-3][0]||'').trim().toUpperCase();
      const prenom = (A2[r-4][0]||'').trim();
      if (!nom && !prenom) continue;
      const key = nom + '|' + prenom;
      if (!clés.has(key)) clés.set(key, []);
      clés.get(key).push({sheet: sh, row1:r});
    }
  });

  // reset
  feuilles.forEach(n=>{
    const sh = ss.getSheetByName(n); if (!sh) return;
    const last = sh.getLastRow(); if (last >= 3) {
      sh.getRange(3,1,last-2,2).setBackground(null); // enlève éventuel jaune
    }
  });

  // surbrillance jaune sur doublons
  clés.forEach(list=>{
    if (list.length <= 1) return;
    list.forEach(({sheet,row1})=>{
      sheet.getRange(row1,1,2,2).setBackground('#FFF3B0'); // jaune doux
    });
  });

  SpreadsheetApp.getActive().toast('Doublons surlignés (jaune)', 'Script', 5);
}






/************
  MASQUAGE
*************/


/** ======== MASQUAGE : constantes & stockage ======== */
const PROP_MASKED_CLIENTS_V2 = 'MASKED_CLIENTS_V2'; // stockage JSON DocumentProperties
const MASK_BG_DARK = '#1F2937'; // gris très foncé (lisible)
const MASK_FG_LIGHT = '#FFFFFF'; // texte clair pour contraste

/** Clé de client stable : NOM|Prénom|TelDigits (TelDigits optionnel) */
function makeClientKey_(nom, prenom, tel) {
  const N = String(nom||'').trim().toUpperCase();
  const P = String(prenom||'').trim();
  const T = String(tel||'').replace(/\D/g,''); // digits only
  return N + '|' + P + '|' + T;
}

/** Lecture du map des masqués : Map<key, untilEpochMs> (en purgeant ce qui a expiré) */
function readMaskedMap_({purgeExpired=true}={}) {
  const props = PropertiesService.getDocumentProperties();
  const raw = props.getProperty(PROP_MASKED_CLIENTS_V2);
  let obj = {};
  try { obj = raw ? JSON.parse(raw) : {}; } catch(_) { obj = {}; }
  // normaliser -> Map
  const m = new Map();
  Object.keys(obj).forEach(k => {
    const v = Number(obj[k]||0) || 0;
    m.set(k, v);
  });
  if (purgeExpired) purgeExpiredMasks_(m);
  return m;
}

/** Écrit le map des masqués dans les propriétés */
function saveMaskedMap_(map) {
  const obj = {};
  map.forEach((until,k)=>{ obj[k]=Number(until)||0; });
  PropertiesService.getDocumentProperties().setProperty(PROP_MASKED_CLIENTS_V2, JSON.stringify(obj));
}

/** Supprime de la map tout masque expiré (<= aujourd'hui 23:59:59 local) */
function purgeExpiredMasks_(map) {
  const now = new Date(); // maintenant
  const todayEnd = new Date(todayMidnight_().getTime() + 24*60*60*1000 - 1);
  let changed = false;
  Array.from(map.entries()).forEach(([k,until]) => {
    if (!until || until <= todayEnd.getTime()) {
      map.delete(k);
      changed = true;
    }
  });
  if (changed) saveMaskedMap_(map);
}

/** Renvoie un Set des clés masquées (déjà purgées) */
function getMaskedKeysSet_() {
  const m = readMaskedMap_({purgeExpired:true});
  return new Set(Array.from(m.keys()));
}


/** ======== MASQUAGE : overlay S+1 sur une feuille ======== */
function appliquerMasquageS1SurFeuille_(sheet) {
  if (!sheet) return;
  if (!isForecastEnabled_ || !isForecastEnabled_()) return; // masquage visible seulement si prévisions actives

  // purge des expirés + set des clés masquées
  const masked = getMaskedKeysSet_();
  if (masked.size === 0) return;

  // S+1 = colonne de début de la semaine suivante
  const startCol = getNextWeekStartCol_(sheet);
  if (!startCol || startCol < FIRST_DATA_COL) return;

  const lastRow = sheet.getLastRow();
  if (lastRow < FIRST_DATA_ROW) return;

  // Lecture minimale pour fabriquer les clés
  // NOM (A, r1), PRÉNOM (A, r2), TÉL (COL_TEL, r2)
  const height = lastRow - (FIRST_DATA_ROW - 1);
  const A_nom   = sheet.getRange(FIRST_DATA_ROW, 1, height, 1).getDisplayValues(); // col A
  const B_tel   = sheet.getRange(FIRST_DATA_ROW, COL_TEL, height, 1).getDisplayValues(); // col tel (B ou autre)

  const a1List = [];
  for (let r1 = FIRST_DATA_ROW; r1 + 1 <= lastRow; r1 += NB_ROWS_BLOCK) {
    const nom    = (A_nom[r1 - FIRST_DATA_ROW][0] || '').trim();
    const prenom = (A_nom[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim(); // ligne 2 (r1+1), même col A
    const tel    = (B_tel[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim(); // ligne 2 (r1+1), col TEL
    const key = makeClientKey_(nom, prenom, tel);
    if (!masked.has(key)) continue;

    // Plage S+1 du bloc (2 lignes, 1 colonne)
    const rg = sheet.getRange(r1, startCol, NB_ROWS_BLOCK, 1);
    a1List.push(rg.getA1Notation());
  }

  if (a1List.length) {
    sheet.getRangeList(a1List).setBackground(MASK_BG_DARK).setFontColor(MASK_FG_LIGHT);
  }
}


/** ======== MASQUAGE : services UI ======== */

/** Liste pour UI : clients (non masqués) et masqués (avec échéance) */
function uiListClientsPourMasquage_() {
  const ss = SpreadsheetApp.getActive();
  const feuilles = [SHEET_CLIENTS, SHEET_PONCTUEL];
  const maskedMap = readMaskedMap_({purgeExpired:true});
  const masked = new Set(Array.from(maskedMap.keys()));

  const outClients = []; // {key,label}
  const outMasked  = []; // {key,label, untilISO}

  feuilles.forEach(n => {
    const sh = ss.getSheetByName(n); if (!sh) return;
    const last = sh.getLastRow(); if (last < FIRST_DATA_ROW) return;

    const h = last - (FIRST_DATA_ROW - 1);
    const A = sh.getRange(FIRST_DATA_ROW, 1, h, 1).getDisplayValues();            // NOM/PRÉNOM
    const T = sh.getRange(FIRST_DATA_ROW, COL_TEL, h, 1).getDisplayValues();      // TÉL
    for (let r1=FIRST_DATA_ROW; r1+1<=last; r1+=NB_ROWS_BLOCK) {
      const nom    = (A[r1 - FIRST_DATA_ROW][0] || '').trim();
      const prenom = (A[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim();
      const tel    = (T[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim();
      const key = makeClientKey_(nom, prenom, tel);
      if (!nom && !prenom) continue;

      const label = `${nom || '(Sans NOM)'} ${prenom || ''}`.trim() + ` — ${n}`;
      if (masked.has(key)) {
        const until = maskedMap.get(key) || 0;
        const untilISO = until ? Utilities.formatDate(new Date(until), Session.getScriptTimeZone() || 'Europe/Paris', 'yyyy-MM-dd') : '';
        outMasked.push({key, label, untilISO});
      } else {
        outClients.push({key, label});
      }
    }
  });

  // Tri alpha
  outClients.sort((a,b)=>a.label.localeCompare(b.label, 'fr'));
  outMasked.sort((a,b)=>a.label.localeCompare(b.label, 'fr'));
  return {clients: outClients, masked: outMasked};
}

/** Calcule la prochaine date d’intervention planifiée (si existante) pour un client (clé) */
function uiComputeNextPlanifDate_(key) {
  const loc = findBlockByKeyAcrossSheets_(key);
  if (!loc) return { ok:false, message:'Client introuvable' };
  const { sheet, r1 } = loc;

  // Besoin des plages (une par semaine)
  const cache = getPlagesCachedForSheet_(sheet);
  const plages = cache && cache.plages; if (!plages || !plages.length) return {ok:false, message:'Plages non disponibles'};

  // On lit l’affichage sur la ligne 1 et 2 pour détecter une planif future
  const lastCol = sheet.getLastColumn();
  const width = lastCol - (FIRST_DATA_COL - 1);
  if (width <= 0) return {ok:false, message:'Aucune colonne de données'};
  const rowDisp = sheet.getRange(r1, FIRST_DATA_COL, NB_ROWS_BLOCK, width).getDisplayValues();
  const row1 = rowDisp[0], row2 = rowDisp[1];

  // Semaine courante + 1
  const startCol = getNextWeekStartCol_(sheet);
  const jStart = startCol - FIRST_DATA_COL;

  // Cherche la première colonne >= S+1 où l’une des 2 lignes est non vide
  for (let j=jStart; j<width && j<plages.length; j++) {
    const v1 = String(row1[j]||'').trim();
    const v2 = String(row2[j]||'').trim();
    if (v1 !== '' || v2 !== '') {
      const d = plages[j].start; // Date JS
      const iso = Utilities.formatDate(new Date(d), Session.getScriptTimeZone()||'Europe/Paris', 'yyyy-MM-dd');
      return {ok:true, dateISO: iso};
    }
  }
  return {ok:false, message:'Aucune planification future trouvée'};
}

/** Masque un client jusqu’à une date (ISO) OU jusqu’à la prochaine planif */
function uiMaskClient_(payload) {
  const { key, mode, dateISO } = payload || {};
  if (!key) return {ok:false, message:'Aucun client sélectionné'};
  const map = readMaskedMap_({purgeExpired:true});
  let untilMs = 0;

  if (mode === 'date') {
    if (!dateISO) return {ok:false, message:'Date manquante'};
    // jusqu’à 23:59:59 local de la date choisie
    const tz = Session.getScriptTimeZone() || 'Europe/Paris';
    const [y,m,d] = dateISO.split('-').map(n=>parseInt(n,10));
    untilMs = new Date(y, m-1, d, 23,59,59,999).getTime();
  } else if (mode === 'next') {
    const r = uiComputeNextPlanifDate_(key);
    if (!r.ok) return r;
    const [y,m,d] = r.dateISO.split('-').map(n=>parseInt(n,10));
    // On masque jusqu’à la veille (23:59) de cette date de planif ou jusqu’à cette date ? 
    // Choix user-friendly : jusqu’à la veille -> la S+1 avant cette date sera grisée, et dès la semaine de la date, ça redevient normal.
    untilMs = new Date(y, m-1, d, 0,0,0,0).getTime() - 1;
  } else {
    return {ok:false, message:'Mode invalide'};
  }

  map.set(key, untilMs);
  saveMaskedMap_(map);

  // Repeindre S+1 (les 2 feuilles) si prévisions actives
  try { surlignerSemaineEnCoursToutesFeuilles_(); } catch(_){}
  return {ok:true, data: uiListClientsPourMasquage_()};
}

/** Démasque un client (suppression) */
function uiUnmaskClient_(key) {
  const map = readMaskedMap_({purgeExpired:false});
  map.delete(key);
  saveMaskedMap_(map);
  try { surlignerSemaineEnCoursToutesFeuilles_(); } catch(_){}
  return {ok:true, data: uiListClientsPourMasquage_()};
}

/** Localise un bloc par clé (sur l’une des 2 feuilles) */
function findBlockByKeyAcrossSheets_(key) {
  const ss = SpreadsheetApp.getActive();
  const feuilles = [SHEET_CLIENTS, SHEET_PONCTUEL];
  for (const n of feuilles) {
    const sh = ss.getSheetByName(n); if (!sh) continue;
    const last = sh.getLastRow(); if (last < FIRST_DATA_ROW) continue;
    const h = last - (FIRST_DATA_ROW - 1);
    const A = sh.getRange(FIRST_DATA_ROW, 1, h, 1).getDisplayValues();
    const T = sh.getRange(FIRST_DATA_ROW, COL_TEL, h, 1).getDisplayValues();
    for (let r1=FIRST_DATA_ROW; r1+1<=last; r1+=NB_ROWS_BLOCK) {
      const nom    = (A[r1 - FIRST_DATA_ROW][0] || '').trim();
      const prenom = (A[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim();
      const tel    = (T[r1 - FIRST_DATA_ROW + 1]?.[0] || '').trim();
      const k = makeClientKey_(nom, prenom, tel);
      if (k === key) return {sheet: sh, r1};
    }
  }
  return null;
}

function masquerClientDialog() {
  const html = HtmlService.createHtmlOutputFromFile('masquerClient')
    .setWidth(520).setHeight(420);
  SpreadsheetApp.getUi().showModalDialog(html, 'Masquer un client');
}

function refreshWeekHighlightDaily_() {
  try {
    // purge puis repaint
    readMaskedMap_({purgeExpired:true}); // purgera et sauvegardera si nécessaire
    surlignerSemaineEnCoursToutesFeuilles_();
    try { focusHighlightedWeekAtOpen_(); } catch(_){}
  } catch(e) { Logger.log(e); }
}




